{"version":3,"file":"vfyjs.browser.js","mappings":"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","sources":["webpack://vfyjs/webpack/universalModuleDefinition","webpack://vfyjs/./index.js","webpack://vfyjs/./node_modules/path-browserify/index.js","webpack://vfyjs/./src/common/validationConstants.js","webpack://vfyjs/./src/errors/FormError.js","webpack://vfyjs/./src/errors/HandleError.js","webpack://vfyjs/./src/utils/handleOption.js","webpack://vfyjs/./src/utils/inputValidator.js","webpack://vfyjs/./src/utils/operations/mathUtils.js","webpack://vfyjs/./src/validator/colors/isColor.js","webpack://vfyjs/./src/validator/form/email.js","webpack://vfyjs/./src/validator/form/helper/dataConversion.js","webpack://vfyjs/./src/validator/form/helper/genOption.js","webpack://vfyjs/./src/validator/form/helper/getValues.js","webpack://vfyjs/./src/validator/form/password.js","webpack://vfyjs/./src/validator/form/username.js","webpack://vfyjs/./src/validator/links/http.js","webpack://vfyjs/./src/validator/links/https.js","webpack://vfyjs/./src/validator/phone/config/phoneDataHandler.js","webpack://vfyjs/./src/validator/phone/continents/Africa.js","webpack://vfyjs/./src/validator/phone/continents/America/central.js","webpack://vfyjs/./src/validator/phone/continents/America/north.js","webpack://vfyjs/./src/validator/phone/continents/America/south.js","webpack://vfyjs/./src/validator/phone/continents/Asia.js","webpack://vfyjs/./src/validator/phone/continents/Europe.js","webpack://vfyjs/./src/validator/phone/continents/Oceania.js","webpack://vfyjs/./src/validator/phone/countries/Africa.js","webpack://vfyjs/./src/validator/phone/countries/America/central.js","webpack://vfyjs/./src/validator/phone/countries/America/north.js","webpack://vfyjs/./src/validator/phone/countries/America/south.js","webpack://vfyjs/./src/validator/phone/countries/Asian.js","webpack://vfyjs/./src/validator/phone/countries/Europe.js","webpack://vfyjs/./src/validator/phone/countries/Oceania.js","webpack://vfyjs/./src/validator/phone/phoneValidator.js","webpack://vfyjs/./src/validator/phone/utils/FormatValidation.js","webpack://vfyjs/./src/validator/phone/utils/GlobalValidation.js","webpack://vfyjs/webpack/bootstrap","webpack://vfyjs/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vfyjs\"] = factory();\n\telse\n\t\troot[\"vfyjs\"] = factory();\n})(this, () => {\nreturn ","/**\r\n * Provides functions for validating various input types, such as passwords, emails,\r\n * usernames, URLs, phone numbers, and colors. Additionally, utility functions for input\r\n * validation and error handling are included.\r\n *\r\n * @module Validator\r\n * @namespace\r\n */\r\n\r\n// Importing password validation function\r\nconst passwordValidate = require(\"./src/validator/form/password\");\r\n\r\n// Importing email validation function\r\nconst emailValidate = require(\"./src/validator/form/email\");\r\n\r\n// Importing username validation function\r\nconst userValidate = require(\"./src/validator/form/username\");\r\n\r\n// Importing HTTP link validation function\r\nconst isHttp = require(\"./src/validator/links/http\");\r\n\r\n// Importing HTTPS link validation function\r\nconst isHttps = require(\"./src/validator/links/https\");\r\n\r\n// Importing color validation function\r\nconst colorValidate = require(\"./src/validator/colors/isColor\");\r\n\r\n// Importing phone number validation function\r\nconst validatePhoneNumber = require(\"./src/validator/phone/phoneValidator\");\r\n\r\n// Importing utility functions for input validation\r\nconst inputValidations = require(\"./src/utils/inputValidator\");\r\n\r\n// Importing utility function for extracting substrings\r\nconst {\r\n  getSubstring,\r\n} = require(\"./src/validator/phone/utils/FormatValidation\");\r\n\r\n// Importing utility function for trimming values\r\nconst { trimmedValue } = require(\"./src/common/validationConstants\");\r\n\r\n// Importing error handling module\r\nconst HandleError = require(\"./src/errors/HandleError\");\r\n// Importing math operations module\r\nconst MathOperations = require(\"./src/utils/operations/mathUtils\");\r\n\r\nmodule.exports = {\r\n  /**\r\n   * Validates a password based on specified criteria.\r\n   *\r\n   * @function\r\n   * @param {string} value - The password string to be validated.\r\n   * @param {Object} options - Options for customizing validation criteria.\r\n   * @returns {boolean} - True if the password is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isPassword: passwordValidate,\r\n  /**\r\n   * Validates an email address.\r\n   *\r\n   * @function\r\n   * @param {string} email - The email address to be validated.\r\n   * @returns {boolean} - True if the email is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isEmail: emailValidate,\r\n  /**\r\n   * Validates a username.\r\n   *\r\n   * @function\r\n   * @param {string} username - The username to be validated.\r\n   * @returns {boolean} - True if the username is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isUsername: userValidate,\r\n  /**\r\n   * Validates a color string.\r\n   *\r\n   * @function\r\n   * @param {string} color - The color string to be validated.\r\n   * @returns {boolean} - True if the color is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isColor: colorValidate,\r\n\r\n  /**\r\n   * Validates an HTTP link.\r\n   *\r\n   * @function\r\n   * @param {string} link - The HTTP link to be validated.\r\n   * @returns {boolean} - True if the link is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isHttp: isHttp,\r\n  /**\r\n   * Validates an HTTPS link.\r\n   *\r\n   * @function\r\n   * @param {string} link - The HTTPS link to be validated.\r\n   * @returns {boolean} - True if the link is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  isHttps: isHttps,\r\n  /**\r\n   * Validates a phone number.\r\n   *\r\n   * @function\r\n   * @param {string} phoneNumber - The phone number to be validated.\r\n   * @returns {boolean} - True if the phone number is valid, otherwise false.\r\n   * @throws {Error} - Throws an error if validation fails.\r\n   */\r\n  hasPhone: validatePhoneNumber,\r\n  /**\r\n   * Provides utility functions for input validation.\r\n   *\r\n   * @namespace\r\n   * @property {function}\r\n   */\r\n  inputValidations: inputValidations,\r\n  /**\r\n   * Extracts a substring from a phone number.\r\n   *\r\n   * @function\r\n   * @param {string} phoneNumber - The phone number from which to extract a substring.\r\n   * @returns {string} - The extracted substring.\r\n   */\r\n  getSubstring: getSubstring,\r\n\r\n  /**\r\n   * Trims a value.\r\n   *\r\n   * @function\r\n   * @param {any} value - The value to be trimmed.\r\n   * @returns {any} - The trimmed value.\r\n   */\r\n  trimValue: trimmedValue,\r\n  /**\r\n   * Provides functions for handling errors, including numeric type checks.\r\n   *\r\n   * @namespace\r\n   * @property {function}\r\n   */\r\n  HandleError: HandleError,\r\n  /**\r\n   * Provides utility functions for mathematical operations.\r\n   *\r\n   * @namespace\r\n   * @property {MathOperations}\r\n   */\r\n  mathOperations: MathOperations,\r\n};\r\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/**\r\n * Minimum length requirement for passwords.\r\n * @constant {number}\r\n */\r\nconst MIN_LENGTH = 8;\r\n\r\n/**\r\n * Maximum length requirement for passwords.\r\n * @constant {number}\r\n */\r\nconst MAX_LENGTH = 64;\r\n\r\n/**\r\n * Removes leading and trailing whitespaces from a string.\r\n *\r\n * @function\r\n * @param {string} value - The input string to be trimmed.\r\n * @returns {string} - The input string with leading and trailing whitespaces removed.\r\n *\r\n * @example\r\n * // Example: Trimming whitespaces from a string\r\n * const inputString = '    H   ell o,    World!   ';\r\n * const result = trimmedValue(inputString);\r\n * console.log(result);\r\n * // Output: 'Hello,World!'\r\n */\r\nconst trimmedValue = (value) => value.replace(/\\s/g, '').trim();\r\n/**\r\n * Module exports containing constants and functions related to password validation.\r\n * @module validationConstants\r\n */ \r\nfunction getRequired(value, defaultValue) {\r\n    return value && value.required ? value.required : defaultValue;\r\n}\r\nfunction getFalseRequired(value){\r\n    return value && !value.required ? value.required : value;\r\n}\r\nfunction getValidValue(value, defaultValue ){\r\n    return value && value.value ? value.value : defaultValue;\r\n}\r\nfunction isValue(value, defaultValue){\r\n    if(typeof value === 'object'){\r\n        return defaultValue\r\n    }\r\n    return value ? value : defaultValue\r\n}\r\nmodule.exports = { MIN_LENGTH, MAX_LENGTH,getFalseRequired, trimmedValue,getValidValue,isValue,getRequired };\r\n","const { toString } = require(\"../validator/form/helper/dataConversion\");\r\n\r\nclass ValidationError extends Error {\r\n    constructor(message, property, input, errors, validationRule, fieldType, statusError) {\r\n        super(message);\r\n        this.property = property;\r\n        this.input = input;\r\n        this.errors = errors;\r\n        this.value = this.input.value ? this.input.value : 'Input is not a value';\r\n        this.validationRule = validationRule;\r\n        this.fieldType = fieldType;\r\n        this.timestamp = new Date(); \r\n        this.statusError = statusError;\r\n    }\r\n\r\n    getErrorDetails() {\r\n        return {\r\n            property: this.property,\r\n            input: this.input,\r\n            errors: this.errors,\r\n            value: this.value,\r\n            validationRule: this.validationRule,\r\n            fieldType: this.fieldType,\r\n            timestamp: this.timestamp\r\n        };\r\n    }\r\n\r\n    getFormattedMessage() {\r\n        return `${this.name} (${this.id}): ${this.message}`;\r\n    }\r\n\r\n    logError() {\r\n        return `[${this.timestamp}] ${this.name}: ${this.message}`;\r\n    }\r\n\r\n    getInput() {\r\n        return {\r\n            value: this.value,\r\n            errors: this.errors\r\n        };\r\n    }\r\n}\r\nclass ValueTypeError extends ValidationError {}\r\n\r\nclass StringLengthError extends ValidationError {}\r\n\r\nclass BooleanValueError extends ValidationError {}\r\n\r\n\r\n\r\nexports.throwIfFalsy  = (property, input, errors, validationRule,message) => {\r\n    if (!property) {\r\n      throw new BooleanValueError(message ||  'Invalid value (Falsy)', property, input, errors, validationRule, 'boolean', 'Falsy value detected');\r\n    }\r\n    return property;\r\n};\r\n\r\nexports.ifTruthyValue = (message, property, input, errors, validationRule) => {\r\n    if (property) {\r\n        throw new BooleanValueError(message|| 'Invalid value (Truthy)', property, input, errors, validationRule, 'boolean', 'Truthy value detected');\r\n    }\r\n};\r\nexports.validateWithCondition = (condition, validatorFunction, input, msgError, validationRule, errorMessage) =>{\r\n    this.throwIfFalsy(condition ? validatorFunction : true, input, msgError, validationRule, errorMessage);\r\n}\r\nexports.TypeMatches = (expectedType, property, message, input, errors, validationRule) => {\r\n    if (typeof property !== expectedType) {\r\n        throw new ValueTypeError(property, message || `Value should be of type ${expectedType}`, input, errors, validationRule, 'type', 'Type mismatch');\r\n    }\r\n};\r\n\r\nexports.validationsLength = (value, minLength, maxLength, message, input, errors, validationRule) => {\r\n    const length = typeof value === 'string' ? value.length : toString(value).length;\r\n    if (length < minLength || length > maxLength) {\r\n        throw new StringLengthError(message || `Value must be between ${minLength} and ${maxLength} characters long`, value, input, errors, validationRule, 'length', 'Length out of range');\r\n    }\r\n};\r\nexports.IfBothTruthy = (property, method, message,input,errors,validationRule) => {\r\n    if (property) {\r\n      if (method) {\r\n        this.ifTruthyValue(message || 'Invalid Input',property,input,errors,validationRule);\r\n      }\r\n    }\r\n  };","/**\r\n * Custom error class for validation-related errors.\r\n * @class\r\n * @extends Error\r\n * @param {string} property - The property or field associated with the validation error.\r\n * @param {string} message - The error message describing the validation failure.\r\n */\r\nclass CustomError extends Error {\r\n  constructor(property, message) {\r\n    super(message);\r\n    this.property = property;\r\n    this.message = message\r\n  }\r\n}\r\n/**\r\n * Specific error class for validation errors.\r\n * @class\r\n * @extends CustomError\r\n */\r\nclass ValidationError extends CustomError {}\r\n\r\n/**\r\n * Specific error class for type errors.\r\n * @class\r\n * @extends CustomError\r\n */\r\nclass TypeError extends CustomError {}\r\n\r\n/**\r\n * Specific error class for length-related errors.\r\n * @class\r\n * @extends CustomError\r\n */\r\nclass LengthError extends CustomError {}\r\n\r\n/**\r\n * Throws a validation error if the specified property is truthy.\r\n *\r\n * @param {any} property - The property or condition to be validated.\r\n * @param {string} message - The error message for the validation failure.\r\n * @returns {any} - Returns the input property if it is falsy.\r\n * @throws {ValidationError} - Throws a validation error with the specified property and message if validation fails.\r\n *\r\n * @example\r\n * // Example: Throw error if value is empty\r\n * try {\r\n *   ifFalsyValue('', 'Value should not be empty');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'ValidationError'\r\n *   console.error(error.message); // 'Value should not be empty'\r\n * }\r\n */\r\nexports.ifFalsyValue = (property, message) => {\r\n  if (!property) {\r\n    throw new ValidationError(property, message || 'Invalid value');\r\n  }\r\n  return property;\r\n};\r\n/**\r\n * Validates if the provided property is truthy.\r\n *\r\n * @param {any} property - The property to be validated.\r\n * @param {string} message - The error message for the validation failure.\r\n * @throws {ValidationError} - Throws a validation error with the specified property and message if validation fails.\r\n * @returns {boolean} - Returns true if the property is falsy.\r\n *\r\n * @example\r\n * // Example: Throw error if value is truthy\r\n * try {\r\n *   ifTruthyValue('Some Value', 'Invalid value');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'ValidationError'\r\n *   console.error(error.message); // 'Invalid value'\r\n * }\r\n */\r\nexports.ifTruthyValue = (property, message) => {\r\n  if (property) {\r\n    throw new ValidationError(property, message || 'Invalid value');\r\n  }\r\n  return property;\r\n};\r\n/**\r\n * Validates if both the provided property and method are truthy.\r\n *\r\n * @param {any} property - The property to be validated.\r\n * @param {any} method - The method or condition to be validated.\r\n * @param {string} message - The error message to be associated with the validation failure.\r\n * @throws {ValidationError} - Throws a validation error with the specified property and message if validation fails.\r\n * \r\n * @example\r\n * // Example: Validate if password has at least one number and is not empty\r\n * const userPassword = 'Secret123';\r\n * try {\r\n *   validateIfBothTruthy(\r\n *     userPassword, \r\n *     userPassword && /\\d/.test(userPassword), \r\n *     'Invalid password. It must contain at least one number and should not be empty.'\r\n *   );\r\n *   console.log('Password is valid.');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'ValidationError'\r\n *   console.error(error.message); // 'Invalid password. It must contain at least one number and should not be empty.'\r\n * }\r\n */\r\nexports.validateIfBothTruthy = (property, method, message) => {\r\n  if (property) {\r\n    if (method) {\r\n      this.ifTruthyValue(property, message || 'Invalid Input');\r\n    }\r\n  }\r\n};\r\n/**\r\n * Throws a type error if the type of the specified property is not as expected.\r\n *\r\n * @param {string} expectedType - The expected type of the property.\r\n * @param {any} property - The property to be validated for its type.\r\n * @param {string} message - The error message to be associated with the type validation failure.\r\n * @throws {TypeError} - Throws a type error with the specified property and message if type validation fails.\r\n * \r\n * @example\r\n * // Example: Validate if the age is a number\r\n * const userAge = '25'; // Note: '25' is a string, not a number\r\n * try {\r\n *   IfNotType('number', userAge, 'Age should be a number');\r\n *   console.log('Age is valid.');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'TypeError'\r\n *   console.error(error.message); // 'Age should be a number'\r\n * }\r\n */\r\nexports.IfNotType = (expectedType, property, message) => {\r\n  if (typeof property !== expectedType) {\r\n    throw new TypeError(property, message || `Property should be of type ${expectedType}`);\r\n  }\r\n};\r\n/**\r\n * Checks if the type of the specified property mismatches the expected type.\r\n *\r\n * @param {string} type - The expected type of the property.\r\n * @param {any} property - The property to be validated for its type.\r\n * @returns {undefined} - Returns undefined if type matches, indicating a mismatch.\r\n * @example\r\n * if (isTypeMismatch('undefined', someProperty)) {\r\n *   // Handle the type mismatch\r\n * }\r\n */\r\nexports.isTypeMismatch = (expectedType, property) => {\r\n  if (typeof property !== expectedType) {\r\n    return;\r\n  }\r\n};\r\n/**\r\n * Throws a type error if the type of the specified property matches the expected type.\r\n *\r\n * This function is used to throw a type error if the type of the provided property matches the expected type.\r\n *\r\n * @param {string} expectedType - The expected type of the property.\r\n * @param {any} property - The property to be validated for its type.\r\n * @param {string} message - The error message to be associated with the type validation failure.\r\n * @throws {TypeError} - Throws a type error with the specified property and message if type validation fails.\r\n *\r\n * @example\r\n * // Example: Throw error if value is not a string\r\n * try {\r\n *   IfTypeMatches('string', 42, 'Value should be a string');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'TypeError'\r\n *   console.error(error.message); // 'Value should be a string'\r\n * }\r\n */\r\nexports.IfTypeMatches = (expectedType, property, message) => {\r\n  if (typeof property === expectedType) {\r\n    throw new TypeError(property, message || `Value should be of type ${expectedType}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Throws a type error if the specified property is a valid number (not NaN).\r\n *\r\n * This function checks if the provided property is a valid number (not NaN),\r\n * and if so, it throws a type error with the specified property and message.\r\n *\r\n * @param {any} property - The property to be validated for not being a valid number.\r\n * @param {string} message - The error message to be associated with the type validation failure.\r\n * @throws {TypeError} - Throws a type error with the specified property and message if the property is a valid number.\r\n *\r\n * @example\r\n * // Example: Throw error if value is a number\r\n * const value = 42;\r\n * try {\r\n *   IfIsNumber(value, 'Value should not be a number');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'TypeError'\r\n *   console.error(error.message); // 'Value should not be a number'\r\n * }\r\n */\r\nexports.IfIsNumber = (property, message) => {\r\n  if (!isNaN(property)) {\r\n    throw new TypeError(property, message || 'Value should not be a number');\r\n  }\r\n};\r\n\r\n/**\r\n * Validates the length of a value within the specified range.\r\n *\r\n * This function checks if the length of the provided value is within the specified range,\r\n * and if not, it throws an error with the specified message.\r\n *\r\n * @param {string} value - The value to be validated.\r\n * @param {number} minLength - The minimum allowed length.\r\n * @param {number} maxLength - The maximum allowed length.\r\n * @param {string} [message] - The error message to be associated with the length validation failure.\r\n * @throws {Error} - Throws an error with the specified message if length validation fails.\r\n *\r\n * @example\r\n * // Example: Validate the length of a string\r\n * const stringValue = 'abc';\r\n * try {\r\n *   validateLength(stringValue, 2, 5, 'Length should be between 2 and 5 characters.');\r\n *   console.log('Length is valid.');\r\n * } catch (error) {\r\n *   console.error(error.message); // 'Length should be between 2 and 5 characters.'\r\n * }\r\n */\r\nexports.validateLength = (value, minLength, maxLength, message) => {\r\n  const length = typeof value === 'string' ? value.length : `${value}`.length;\r\n  if (length < minLength || length > maxLength) {\r\n    throw new LengthError(value, message || `Length must be between ${minLength} and ${maxLength || value} characters.`);\r\n  }\r\n};\r\n/**\r\n * Validates the length and type of a property.\r\n *\r\n * This function combines type validation and length validation for a given property.\r\n * If the type or length validation fails, it throws an error with the specified message.\r\n *\r\n * @param {any} property - The property to be validated.\r\n * @param {number} minLength - The minimum allowed length.\r\n * @param {number} maxLength - The maximum allowed length.\r\n * @param {string} minLengthType - The expected type for minLength.\r\n * @param {string} maxLengthType - The expected type for maxLength.\r\n * @param {string} message - The error message to be associated with the validation failure.\r\n * @throws {TypeError|LengthError} - Throws a TypeError or LengthError with the specified message if type or length validation fails.\r\n *\r\n * @example\r\n * // Example: Validate both type and length of a property\r\n * const propertyValue = 'abc';\r\n * try {\r\n *   validatePropertyLengthAndType(propertyValue, 2, 5, 'number', 'string', 'Invalid value');\r\n *   console.log('Property is valid.');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'TypeError' or 'LengthError'\r\n *   console.error(error.message); // 'Invalid value' or 'Length must be between 2 and 5 characters.'\r\n * }\r\n */\r\nexports.validatePropertyLengthAndType = (minLength,maxLength,minLengthType,maxLengthType,property,message) => {\r\n  this.IfTypeMatches(minLengthType, property, message);\r\n  this.IfTypeMatches(maxLengthType, property, message);\r\n  this.validateLength(property, minLength, maxLength, message);\r\n};\r\n/**\r\n * Throws a type error if the type of the specified property is not one of the expected types.\r\n *\r\n * This function checks if the type of the provided property is not one of the expected types,\r\n * and if so, it throws a type error with the specified property and message.\r\n *\r\n * @param {any} property - The property to be validated for its type.\r\n * @param {string[]} expectedTypes - An array of expected types.\r\n * @param {string} [message] - The error message to be associated with the type validation failure.\r\n * @throws {TypeError} - Throws a type error with the specified property and message if type validation fails.\r\n *\r\n * @example\r\n * // Example: Throw error if value is not a number or a string\r\n * const value = '42';\r\n * try {\r\n *   TypesCheck(value, ['number', 'string'], 'Value should be a number or a string');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'TypeError'\r\n *   console.error(error.message); // 'Value should be a number or a string'\r\n * }\r\n */\r\nexports.TypesCheck = (property, types, message) => {\r\n  if (!types.includes(typeof property)) {\r\n    throw new TypeError(property, message || `${property} is not of type ${types.join(' or ')}`);\r\n  }\r\n};\r\n/**\r\n * Checks if a value is empty and throws an error if it is.\r\n *\r\n * This function checks if the provided value is empty (falsy), and if so,\r\n * it throws an error with the specified message. Otherwise, it returns the input value.\r\n *\r\n * @param {any} value - The value to be checked for emptiness.\r\n * @param {string} [message='Value should not be empty'] - The error message to be associated with the emptiness check failure.\r\n * @throws {Error} - Throws an error with the specified message if the value is empty.\r\n * @returns {any} - Returns the input value if it is not empty.\r\n * \r\n * @example\r\n * try {\r\n *   isEmpty('someValue', 'The value must not be empty');\r\n * } catch (error) {\r\n *   console.error(error.name); // 'Error'\r\n *   console.error(error.message); // 'The value must not be empty'\r\n * }\r\n */\r\nexports.isEmpty = (value, message = 'Value should not be empty') => {\r\n  if (value === null || value === undefined || value === \"\" || value === 0) {\r\n    throw new ValidationError(value, message);\r\n  }\r\n  return value;\r\n};\r\n/**\r\n * Validates the length of a value within the specified range.\r\n *\r\n * @param {string} value - The value to be validated.\r\n * @param {Object} options - The options for length validation.\r\n * @param {number} options.min - The minimum allowed length.\r\n * @param {string} [options.minMessage] - The error message for minimum length validation failure.\r\n * @param {number} options.max - The maximum allowed length.\r\n * @param {string} [options.maxMessage] - The error message for maximum length validation failure.\r\n * @throws {LengthError} Throws a LengthError if length validation fails.\r\n *\r\n * @example\r\n * // Example: Validate the length of a string\r\n * const stringValue = 'abc';\r\n * try {\r\n *   validationsLen(stringValue, {\r\n *     min: 2,\r\n *     max: 5,\r\n *     minMessage: 'Length should be at least 2 characters.',\r\n *     maxMessage: 'Length should be at most 5 characters.'\r\n *   });\r\n *   console.log('Length is valid.');\r\n * } catch (error) {\r\n *   console.error(error.message); // 'Length should be at least 2 characters.' or 'Length should be at most 5 characters.'\r\n * }\r\n *\r\n * @throws {LengthError} Throws a LengthError with a specified message if length validation fails.\r\n */\r\nexports.validationsLen = (value, options) => {\r\n  const length = typeof value === 'string' ? value.length : `${value}`.length;\r\n  if (options.min && length < options.min) {\r\n    throw new LengthError(value, options.minMessage || `Length must be at least ${options.min} characters.`);\r\n  }\r\n\r\n  if (options.max && length > options.max) {\r\n    throw new LengthError(value, options.maxMessage || `Length must be at most ${options.max} characters.`);\r\n  }\r\n};\r\n\r\n/**\r\n * Validates the minimum length of a value.\r\n *\r\n * This function checks if the length of the provided value is at least the specified minimum,\r\n * and if not, it throws an error with the specified message.\r\n *\r\n * @param {string} value - The value to be validated.\r\n * @param {object} options - Options object containing minimum length and error message.\r\n * @param {number} options.min - The minimum allowed length.\r\n * @param {string} [options.minMessage] - The error message for minimum length validation failure.\r\n * @throws {LengthError} - Throws a LengthError with the specified message if minimum length validation fails.\r\n *\r\n * @example\r\n * // Validate the minimum length of a string\r\n * const stringValue = 'abc';\r\n * try {\r\n *   validateMinLen(stringValue, { min: 2, minMessage: 'Length should be at least 2 characters.' });\r\n *   console.log('Length is valid.');\r\n * } catch (error) {\r\n *   console.error(error.message); // 'Length should be at least 2 characters.'\r\n * }\r\n */\r\nexports.validateMinLen = (value, options) => {\r\n  this.validationsLen(value, { min: options.min, minMessage: options.minMessage || `Value must be at least ${options.min} characters long.` });\r\n};\r\n\r\n/**\r\n * Validates the minimum length of a value.\r\n *\r\n * This function checks if the length of the provided value is at least the specified minimum,\r\n * and if not, it throws an error with the specified message.\r\n *\r\n * @param {string} value - The value to be validated.\r\n * @param {object} options - Options object containing minimum length and error message.\r\n * @param {number} options.min - The minimum allowed length.\r\n * @param {string} [options.minMessage] - The error message for minimum length validation failure.\r\n * @throws {LengthError} - Throws a LengthError with the specified message if minimum length validation fails.\r\n *\r\n * @example\r\n * // Validate the minimum length of a string\r\n * const stringValue = 'abc';\r\n * try {\r\n *   validateMinLen(stringValue, { min: 2, minMessage: 'Length should be at least 2 characters.' });\r\n *   console.log('Length is valid.');\r\n * } catch (error) {\r\n *   console.error(error.message); // 'Length should be at least 2 characters.'\r\n * }\r\n */\r\nexports.validateMinLen = (value, options) => {\r\n  this.validationsLen(value, { min: options.min, minMessage: options.minMessage || `Value must be at least ${options.min} characters long.` });\r\n};\r\n\r\n/**\r\n * Validates the maximum length of a value.\r\n *\r\n * This function checks if the length of the provided value is at most the specified maximum,\r\n * and if not, it throws an error with the specified message.\r\n *\r\n * @param {string} value - The value to be validated.\r\n * @param {object} options - Options object containing maximum length and error message.\r\n * @param {number} options.max - The maximum allowed length.\r\n * @param {string} [options.maxMessage] - The error message for maximum length validation failure.\r\n * @throws {LengthError} - Throws a LengthError with the specified message if maximum length validation fails.\r\n *\r\n * @example\r\n * // Validate the maximum length of a string\r\n * const stringValue = 'abc';\r\n * try {\r\n *   validateMaxLen(stringValue, { max: 5, maxMessage: 'Length should be at most 5 characters.' });\r\n *   console.log('Length is valid.');\r\n * } catch (error) {\r\n *   console.error(error.message); // 'Length should be at most 5 characters.'\r\n * }\r\n */\r\nexports.validateMaxLen = (value, options) => {\r\n  this.validationsLen(value, { max: options.max, maxMessage: options.maxMessage || `Value must be at most ${options.max} characters long.` });\r\n};","/**\r\n * @typedef {Object} ValidationOption\r\n * @property {any} value - The final value of the option after applying the default value or calling the function.\r\n * @property {string} errorMessage - The provided error message.\r\n * @property {boolean} validation - The provided validation function or a default value of `true` if no validation function is provided.\r\n */\r\n\r\n/**\r\n * Utility function to handle default values for options.\r\n *\r\n * @param {any|Function} defaultValue - The default value for the option. If it's a function, the function will be called to get the actual value.\r\n * @param {string} errorMessage - The error message to be displayed if validation fails.\r\n * @returns {{ value: any, errorMessage: string, validation: boolean }} - An object representing the structured option.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const option1 = handleOption(\"default_value\", \"Invalid input\");\r\n * console.log(option1.value); // \"default_value\"\r\n * console.log(option1.errorMessage); // \"Invalid input\"\r\n * console.log(option1.validation); // true\r\n */\r\nfunction handleOption(defaultValue, errorMessage) {\r\n    let option;\r\n  \r\n   /**\r\n     * Object representing a structured option.\r\n     *\r\n     * @typedef {Object} Option\r\n     * @property {any} value - The final value of the option after applying the default value or calling the function.\r\n     * @property {string} errorMessage - The provided error message.\r\n     * @property {Function|boolean} validation - The provided validation function or a default value of `true` if no validation function is provided.\r\n     */\r\n  \r\n    if (typeof defaultValue === 'number') {\r\n      option = /** @type {ValidationOption} */ {\r\n        value: defaultValue,\r\n        errorMessage: errorMessage,\r\n      };\r\n    } else {\r\n      option = /** @type {ValidationOption} */ {\r\n        required: defaultValue,\r\n        errorMessage: errorMessage,\r\n      };\r\n    }\r\n    return option;\r\n  }\r\n\r\n\r\n/**\r\n * Creates validation options based on provided names, validations, and error messages.\r\n *\r\n * @param {Array<string>} name - Array of option names.\r\n * @param {Array<Function|boolean>} validations - Array of validation functions or boolean values.\r\n * @param {Array<string>} errorMessages - Array of error messages corresponding to each option.\r\n * @returns {ValidationOptions} - An object containing options with their structured values.\r\n *\r\n * @example\r\n * // Example usage:\r\n * const name = ['minlength', 'maxLength', 'uppercase'];\r\n * const validations = [validator.hasMinLength(8), validator.hasMaxLength(20), true];\r\n * const errorMessages = ['Password must be at least 8 characters long.', 'Password cannot exceed 20 characters.', 'Uppercase letter required.'];\r\n * const options = createValidationOptions(name, validations, errorMessages);\r\n * console.log(options.minlength.value); // Value based on validation function or boolean\r\n * console.log(options.maxLength.value); // Value based on validation function or boolean\r\n * console.log(options.uppercase.value); // Value based on validation function or boolean\r\n * console.log(options.minlength.errorMessage); // 'Password must be at least 8 characters long.'\r\n * console.log(options.maxLength.errorMessage); // 'Password cannot exceed 20 characters.'\r\n * console.log(options.uppercase.errorMessage); // 'Uppercase letter required.'\r\n * console.log(options.minlength.validate(\"example\")); // Use the validation method for the \"minlength\" option\r\n */\r\nconst createValidationOptions = (name = [], validations = [], errorMessages = []) => {\r\n    let options = {};\r\n    for (let i = 0; i < name.length; i++) {\r\n      const optionName = name[i];\r\n      const validation = validations[i];\r\n      const msgError = errorMessages[i];\r\n      options[optionName] = handleOption(validation, msgError);\r\n    }\r\n    return options;\r\n  };\r\n  \r\n  module.exports = createValidationOptions;\r\n","/**\r\n * @typedef {Object} ValidationFunctions\r\n * @property {() => boolean} hasUppercase - Checks if the input has at least one uppercase letter.\r\n * @property {() => boolean} hasLowerCase - Checks if the input has at least one lowercase letter.\r\n * @property {() => boolean} hasNumber - Checks if the input has at least one numeric digit.\r\n * @property {() => boolean} hasSpecialCharacter - Checks if the input has at least one special character.\r\n * @property {() => boolean} hasAlphabetic - Checks if the input contains at least one alphabetic character.\r\n * @property {() => boolean} hasNumeric - Checks if the input contains at least one numeric digit.\r\n * @property {() => boolean} hasAlphanumeric - Checks if the input contains only alphanumeric characters.\r\n * @property {() => boolean} hasWhitespace - Checks if the input contains any whitespace character.\r\n * @property {() => boolean} hasNonAlphanumeric - Checks if the input contains any non-alphanumeric character.\r\n * @property {(minLength: number) => boolean} hasMinLength - Checks if the input has a minimum length.\r\n * @property {(maxLength: number) => boolean} hasMaxLength - Checks if the input has a maximum length.\r\n * @property {(pattern: RegExp) => boolean} matchesCustomPattern - Checks if the input matches a custom regex pattern.\r\n * @property {() => boolean} matchesEmailFormat - Checks if the input matches the standard email format.\r\n * @property {(repeatCount?: number) => boolean} hasRepeat - Checks if the input contains consecutive repeated characters.\r\n */\r\n\r\n/**\r\n * Input validator function.\r\n *\r\n * @function\r\n * @param {string} input - The input string to be validated.\r\n * @returns {ValidationFunctions} - An object with validation functions.\r\n * @example\r\n * const validator = inputValidator(\"Sample123\");\r\n * const isValid = validator.hasUppercase() && validator.hasNumber();\r\n * console.log(isValid); // true\r\n */\r\nconst inputValidator = (input) => ({\r\n  /**\r\n   * Checks if the input has at least one uppercase letter.\r\n   * @returns {boolean} - True if the input has at least one uppercase letter, otherwise false.\r\n   */\r\n  hasUppercase: () => /(?=.*[A-Z])/.test(input),\r\n\r\n  /**\r\n   * Checks if the input has at least one lowercase letter.\r\n   * @returns {boolean} - True if the input has at least one lowercase letter, otherwise false.\r\n   */\r\n  hasLowerCase: () => /(?=.*[a-z])/.test(input),\r\n\r\n  /**\r\n   * Checks if the input has at least one numeric digit.\r\n   * @returns {boolean} - True if the input has at least one numeric digit, otherwise false.\r\n   */\r\n  hasNumber: () => /(?=.*\\d)/.test(input),\r\n\r\n  /**\r\n   * Checks if the input has at least one special character.\r\n   * @returns {boolean} - True if the input has at least one special character, otherwise false.\r\n   */\r\n  hasSpecialCharacter: () =>\r\n    /(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?])/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains at least one alphabetic character.\r\n   * @returns {boolean} - True if the input contains at least one alphabetic character, otherwise false.\r\n   */\r\n  hasAlphabetic: () => /[a-zA-Z]/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains at least one numeric digit.\r\n   * @returns {boolean} - True if the input contains at least one numeric digit, otherwise false.\r\n   */\r\n  hasNumeric: () => /\\d/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains only alphanumeric characters.\r\n   * @returns {boolean} - True if the input contains only alphanumeric characters, otherwise false.\r\n   */\r\n  hasAlphanumeric: () => /^[a-zA-Z0-9]+$/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains any whitespace character.\r\n   * @returns {boolean} - True if the input contains any whitespace character, otherwise false.\r\n   */\r\n  hasWhitespace: () => /\\s/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains any non-alphanumeric character.\r\n   * @returns {boolean} - True if the input contains any non-alphanumeric character, otherwise false.\r\n   */\r\n  hasNonAlphanumeric: () => /[^a-zA-Z0-9]/.test(input),\r\n\r\n  /**\r\n   * Checks if the input has a minimum length.\r\n   * @param {number} minLength - The minimum length to check against.\r\n   * @returns {boolean} - True if the input length is greater than or equal to minLength, otherwise false.\r\n   */\r\n  hasMinLength: (minLength) => input.length >= minLength,\r\n\r\n  /**\r\n   * Checks if the input has a maximum length.\r\n   * @function\r\n   * @param {number} maxLength - The maximum length to check against.\r\n   * @returns {boolean} - True if the input length is less than or equal to maxLength, otherwise false.\r\n   */\r\n  hasMaxLength: (maxLength) => input.length <= maxLength,\r\n\r\n  /**\r\n   * Checks if the input matches a custom regex pattern.\r\n   * @function\r\n   * @param {RegExp} pattern - The custom regex pattern to match against.\r\n   * @returns {boolean} - True if the input matches the custom pattern, otherwise false.\r\n   */\r\n  matchesCustomPattern: (pattern) => pattern.test(input),\r\n\r\n  /**\r\n   * Checks if the input matches the standard email format.\r\n   * @returns {boolean} - True if the input is a valid email, otherwise false.\r\n   */\r\n  matchesEmailFormat: () => /^[\\w.+-]+@[a-zA-Z\\d.-]+\\.{1}[a-zAZ]{2,5}$/.test(input),\r\n\r\n  /**\r\n   * Checks if the input contains consecutive repeated characters.\r\n   * @param {number} [repeatCount=3] - The number of consecutive repeated characters to check for. Defaults to 3 if not specified.\r\n   * @returns {boolean} - True if the input contains at least the specified number of consecutive repeated characters, otherwise false.\r\n   */\r\n  hasRepeat: (repeatCount = 3) =>\r\n    new RegExp(`(.)\\\\1{${repeatCount - 1},}`).test(input),\r\n});\r\n\r\n/**\r\n * Exports the inputValidator function and getValidationErrors function.\r\n * @module inputValidator\r\n * @type {Object}\r\n */\r\nmodule.exports = inputValidator;\r\n","/**\r\n * Represents a collection of mathematical operations on numbers.\r\n * @typedef {Object} MathOperations\r\n * @property {() => boolean} isEqual - Checks if all additional numbers are equal to the base number.\r\n * @property {() => boolean} isEven - Checks if the base number is even.\r\n * @property {() => boolean} areAllOdd - Checks if all numbers (including the base number) are odd.\r\n * @property {() => boolean} isOdd - Checks if the base number is odd.\r\n * @property {() => boolean} areAllEven - Checks if all numbers (including the base number) are even.\r\n * @property {() => number} add - Adds all additional numbers to the base number.\r\n * @property {() => number} subtract - Subtracts all additional numbers from the base number.\r\n * @property {() => Object} isDivisibleBy - Checks if the base number is divisible by each additional number.\r\n * @property {() => number} multiply - Multiplies the base number by all additional numbers.\r\n * @property {() => number} divide - Divides the base number by all additional numbers.\r\n * @property {() => number} power - Raises the base number to the power of all additional numbers.\r\n * @property {(min: number, max: number) => number} generateRandomNumber - Generates a random number within the specified interval.\r\n * @property {(min: number, max: number) => number} generateRandomEvenNumber - Generates a random even number within the specified interval.\r\n * @property {(min: number, max: number) => number} generateRandomOddNumber - Generates a random odd number within the specified interval.\r\n */\r\n\r\n/**\r\n * Defines a MathOperations object with various mathematical operations.\r\n * @param {number} number - The base number for operations.\r\n * @param {...number} numbers - Additional numbers for operations.\r\n * @returns {MathOperations} An object containing various mathematical operations.\r\n * @example\r\n * const math = MathOperations(2, 3, 4, 5);\r\n * console.log(math.isEqual()); // Output: false\r\n * console.log(math.isEven()); // Output: true\r\n * console.log(math.areAllOdd()); // Output: false\r\n * console.log(math.isOdd()); // Output: true\r\n * console.log(math.areAllEven()); // Output: false\r\n * console.log(math.add()); // Output: 14 (2 + 3 + 4 + 5)\r\n * console.log(math.subtract()); // Output: -10 (2 - 3 - 4 - 5)\r\n * console.log(math.isDivisibleBy()); // Output: {3: false, 4: true, 5: false} (2 % 3, 2 % 4, 2 % 5)\r\n * console.log(math.multiply()); // Output: 120 (2 * 3 * 4 * 5)\r\n * console.log(math.divide()); // Output: 0.03333333333333333 (2 / 3 / 4 / 5)\r\n * console.log(math.power()); // Output: 32 (2^3^4^5)\r\n * console.log(math.generateRandomNumber(1, 100)); // Output: Random number between 1 and 100\r\n * console.log(math.generateRandomEvenNumber(1, 100)); // Output: Random even number between 1 and 100\r\n * console.log(math.generateRandomOddNumber(1, 100)); // Output: Random odd number between 1 and 100\r\n */\r\nconst MathOperations = (number, ...numbers) => ({\r\n  /**\r\n   * Checks if all additional numbers passed are equal to the base number.\r\n   * @returns {boolean} True if all additional numbers are equal to the base number, false otherwise.\r\n   */\r\n  isEqual: () => numbers.every((num) => num === number),\r\n\r\n  /**\r\n   * Checks if the base number is even.\r\n   * @returns {boolean} True if the base number is even, false otherwise.\r\n   */\r\n  isEven: () => number % 2 === 0,\r\n\r\n  /**\r\n   * Checks if all numbers (including the base number) are odd.\r\n   * @returns {boolean} True if all numbers are odd, false otherwise.\r\n   */\r\n  areAllOdd: () => [number, ...numbers].every((num) => num % 2 === 0),\r\n\r\n  /**\r\n   * Checks if the base number is odd.\r\n   * @returns {boolean} True if the base number is odd, false otherwise.\r\n   */\r\n  isOdd: () => number % 2 !== 0,\r\n\r\n  /**\r\n   * Checks if all numbers (including the base number) are even.\r\n   * @returns {boolean} True if all numbers are even, false otherwise.\r\n   */\r\n  areAllEven: () => [number, ...numbers].every((num) => num % 2 !== 0),\r\n\r\n  /**\r\n   * Adds all additional numbers to the base number.\r\n   * @returns {number} The result of adding all numbers.\r\n   */\r\n  add: () => numbers.reduce((acc, curr) => acc + curr, number),\r\n\r\n  /**\r\n   * Subtracts all additional numbers from the base number.\r\n   * @returns {number} The result of subtracting all numbers.\r\n   */\r\n  subtract: () => numbers.reduce((acc, curr) => acc - curr, number),\r\n\r\n  /**\r\n   * Checks if the base number is divisible by each additional number.\r\n   * @returns {Object} An object where keys are additional numbers and values are boolean indicating divisibility.\r\n   */\r\n  isDivisibleBy: () => {\r\n    const divisibleBy = {};\r\n    numbers.forEach((num) => {\r\n      divisibleBy[num] = number % num === 0;\r\n    });\r\n    return divisibleBy;\r\n  },\r\n\r\n  /**\r\n   * Multiplies the base number by all additional numbers.\r\n   * @returns {number} The result of multiplying all numbers.\r\n   */\r\n  multiply: () => {\r\n    if (numbers.length === 0) return number;\r\n    return numbers.reduce((acc, curr) => acc * curr, number);\r\n  },\r\n\r\n  /**\r\n   * Divides the base number by all additional numbers.\r\n   * @throws {Error} If any of the additional numbers is zero.\r\n   * @returns {number} The result of dividing all numbers.\r\n   */\r\n  divide: () => {\r\n    if (numbers.length === 0) return number;\r\n    if (numbers.includes(0)) throw new Error(\"Division by zero is not allowed\");\r\n    return numbers.reduce((acc, curr) => acc / curr, number);\r\n  },\r\n  /**\r\n   * Raises the base number to the power of all additional numbers.\r\n   * @returns {number} The result of raising the base number to the power of all additional numbers.\r\n   */\r\n  power: () => numbers.reduce((acc, curr) => acc ** curr, number),\r\n\r\n  /**\r\n   * Generates a random number within the specified interval.\r\n   * @param {number} min - The minimum value of the interval (inclusive).\r\n   * @param {number} max - The maximum value of the interval (inclusive).\r\n   * @returns {number} A random number between min and max.\r\n   */\r\n  generateRandomNumber: (min = 1, max = 1000) =>\r\n    Math.floor(Math.random() * (max - min + 1)) + min,\r\n\r\n  /**\r\n   * Generates a random even number within the specified interval.\r\n   * @param {number} min - The minimum value of the interval (inclusive).\r\n   * @param {number} max - The maximum value of the interval (inclusive).\r\n   * @returns {number} A random even number between min and max.\r\n   */\r\n  generateRandomEvenNumber: (min = 1, max = 1000) => {\r\n    let randomNumber;\r\n    do {\r\n      randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;\r\n    } while (randomNumber % 2 !== 0);\r\n    return randomNumber;\r\n  },\r\n\r\n  /**\r\n   * Generates a random odd number within the specified interval.\r\n   * @param {number} min - The minimum value of the interval (inclusive).\r\n   * @param {number} max - The maximum value of the interval (inclusive).\r\n   * @returns {number} A random odd number between min and max.\r\n   */\r\n  generateRandomOddNumber: (min = 1, max = 1000) => {\r\n    let randomNumber;\r\n    do {\r\n      randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;\r\n    } while (randomNumber % 2 === 0);\r\n    return randomNumber;\r\n  },\r\n});\r\n\r\nmodule.exports = MathOperations;\r\n","const { IfNotType, validateLength, IfIsNumber } = require(\"../../errors/HandleError\");\r\nconst { trimmedValue } = require('../../common/validationConstants');\r\n\r\n/**\r\n * Validates if a given input represents a color in various formats.\r\n *\r\n * @typedef {Object} ColorValidationFunctions\r\n * @property {() => boolean} HEX - Validates if the input represents a valid Hex color (#RRGGBB or #RRGGBBAA).\r\n * @property {() => boolean} NameColor - Validates if the input represents a valid named color.\r\n * @property {() => boolean} RGB - Validates if the input represents a valid RGB color (rgb(R, G, B)).\r\n * @property {() => boolean} RGBA - Validates if the input represents a valid RGBA color (rgba(R, G, B, A)).\r\n * @property {() => boolean} HSL - Validates if the input represents a valid HSL color (hsl(H, S%, L%)).\r\n * @property {() => boolean} CssVar - Validates if the input represents a valid CSS variable (var(--variable)).\r\n * @property {() => boolean} HWB - Validates if the input represents a valid HWB color (hwb(H, W%, B%)).\r\n *\r\n * @returns {ColorValidationFunctions} An object with validation functions and the color string.\r\n *\r\n * @example\r\n * // Example 1: Validating a Hex color\r\n * const { color, HEX } = isColor('#ff6600');\r\n * console.log(color); // '#ff6600'\r\n * console.log(HEX()); // true\r\n * console.log(NameColor()); // false\r\n * console.log(RGB()); // false\r\n *\r\n * @example\r\n * // Example 2: Validating a CSS variable\r\n * const { color, CssVar } = isColor('var(--main-color)');\r\n * console.log(color); // 'var(--main-color)'\r\n * console.log(CssVar()); // true\r\n * console.log(HSL()); // false\r\n * console.log(HWB()); // false\r\n *\r\n * @throws {TypeError} Throws an error if the input is not a string.\r\n * @throws {Error} Throws an error if the trimmed input is empty after removing leading and trailing whitespaces.\r\n * @throws {Error} Throws an error if the length of the input is less than 3 or greater than 255.\r\n */\r\nconst isColor = (color) => {\r\n  /**\r\n   * @type {ColorValidationFunctions}\r\n   */\r\n  const colorValidationFunctions = {\r\n    /**\r\n     * Validates if the input represents a valid Hex color.\r\n     * @returns {boolean} - True if the input is a valid Hex color, otherwise false.\r\n     */\r\n    HEX: () => /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid named color.\r\n     * @returns {boolean} - True if the input is a valid named color, otherwise false.\r\n     */\r\n    NameColor: () => /^[a-zA-Z]+$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid RGB color.\r\n     * @returns {boolean} - True if the input is a valid RGB color, otherwise false.\r\n     */\r\n    RGB: () => /^rgb\\((\\d{1,3}\\s*,\\s*){2}\\d{1,3}\\)$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid RGBA color.\r\n     * @returns {boolean} - True if the input is a valid RGBA color, otherwise false.\r\n     */\r\n    RGBA: () => /^rgba?\\((\\d{1,3}\\s*,\\s*){2}\\d{1,3}(\\s*,\\s*\\d*\\.?\\d+)?\\)$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid HSL color.\r\n     * @returns {boolean} - True if the input is a valid HSL color, otherwise false.\r\n     */\r\n    HSL: () => /^hsla?\\(\\d{1,3}\\s*,\\s*\\d{1,3}%\\s*,\\s*\\d{1,3}%(\\s*,\\s*\\d*\\.?\\d+)?\\)$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid CSS variable.\r\n     * @returns {boolean} - True if the input is a valid CSS variable, otherwise false.\r\n     */\r\n    CssVar: () => /^var\\(--[a-zA-Z][a-zA-Z0-9_-]*\\)$/.test(color),\r\n  \r\n    /**\r\n     * Validates if the input represents a valid HWB color.\r\n     * @returns {boolean} - True if the input is a valid HWB color, otherwise false.\r\n     */\r\n    HWB: () => /^hwb\\(\\d{1,3}\\s*,\\s*\\d{1,3}%\\s*,\\s*\\d{1,3}%(\\s*,\\s*\\d*\\.?\\d+)?\\)$/.test(color),\r\n  };\r\n  return colorValidationFunctions;\r\n};\r\n\r\n/**\r\n * Checks and validates a color value.\r\n *\r\n * @param {string} color - The color value to check and validate.\r\n * @returns {ColorValidationFunctions} An object with validation functions and the color string.\r\n * @throws {TypeError} Throws an error if the input is not a string.\r\n * @throws {Error} Throws an error if the trimmed input is empty after removing leading and trailing whitespaces.\r\n * @throws {Error} Throws an error if the length of the input is less than 3 or greater than 255.\r\n */\r\nfunction checkValueColor(color) {\r\n    IfNotType('string', color, \"The variable is not a string\");\r\n    IfIsNumber(color,'The variable is not a valid color representation as a number.')\r\n    color = trimmedValue(color);\r\n    validateLength(color, 3, 255, 'The color value must be between 3 and 255 characters.');\r\n    return isColor(color);\r\n}\r\n\r\nmodule.exports = checkValueColor;\r\n","\"use strict\";\r\n\r\nconst inputValidator = require(\"../../utils/inputValidator\");\r\nconst { ifFalsyValue,IfNotType , ifTruthyValue, validationsLen } = require(\"../../errors/HandleError\");\r\nconst createValidationOptions = require(\"../../utils/handleOption\");\r\nconst { getValidValue } = require(\"../../common/validationConstants\");\r\n\r\n/**\r\n * Validates whether the provided value is a valid email.\r\n *\r\n * @param {string} value - The input string to be validated as an email.\r\n * @param {Object} [options={}] - Additional options for email validation.\r\n * @param {number} [options.minLenLocal=3] - The minimum length allowed for the local part of the email.\r\n * @param {number} [options.maxLenLocal=255] - The maximum length allowed for the local part of the email.\r\n * @param {number} [options.minLenDomain=3] - The minimum length allowed for the domain part of the email.\r\n * @param {number} [options.maxLenDomain=255] - The maximum length allowed for the domain part of the email.\r\n * @param {number} [options.minLenSubdomain=2] - The minimum length allowed for the subdomain part of the email.\r\n * @param {number} [options.maxLenSubdomain=255] - The maximum length allowed for the subdomain part of the email.\r\n * @returns {boolean} - True if the input is a valid email, otherwise false.\r\n * @throws {TypeError} - Throws a TypeError if the input is not a string.\r\n * @throws {ValidationError} - Throws a ValidationError if the email format is invalid.\r\n * @example\r\n * const { email } = require('vfyjs');\r\n * const isValid = email('mahdimamashli1383@gmail.com', { minLenLocal: 3, maxLenLocal: 255 });\r\n * console.log(isValid); // true\r\n */\r\nfunction validateEmail(value, options = {}) {\r\n  // Check if the input is a string\r\n  IfNotType('string', value, `Invalid input type. Please enter a valid email as a string.`);\r\n\r\n  // Basic email format validation\r\n  const hasSymbol = /^(?!.*@.*@)[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\r\n  ifFalsyValue(hasSymbol, 'Email address must contain the \"@\" symbol.');\r\n  const hasOneDot = /(?=.*(\\.)\\1)/.test(value);\r\n  ifTruthyValue(hasOneDot,'The value must have at most one dot.')\r\n  // Set standard length\r\n  const standardMaxLength = 255;\r\n  const standardMinLength = 3\r\n  // Validation options\r\n  const optionName = ['minLenLocal', 'minLenDomain', 'minLenSubdomain', 'maxLenLocal', 'maxLenDomain', 'maxLenSubdomain'];\r\n  const optionValidations = [standardMinLength,standardMinLength,2, standardMaxLength,standardMaxLength,standardMaxLength];\r\n  const msgError = \r\n  [\r\n    `Local part must have between ${standardMinLength} and ${standardMaxLength} characters.`,\r\n    `Domain part must have between ${standardMinLength} and ${standardMaxLength} characters.`,\r\n    `Subdomain must have between 2 and ${standardMaxLength} characters.`,\r\n    `Local part must have at most ${standardMaxLength} characters.`,\r\n    `Domain part must have at most ${standardMaxLength} characters.`,\r\n    `Subdomain must have at most ${standardMaxLength} characters.`,\r\n  ];\r\n  var objectOPtion = createValidationOptions(optionName,optionValidations,msgError);\r\n  \r\n  objectOPtion = { ...objectOPtion, ...options };\r\n\r\n  const { minLenLocal, minLenDomain, minLenSubdomain, maxLenLocal, maxLenDomain, maxLenSubdomain } = objectOPtion;\r\n\r\n  // Local part length validation\r\n  const localPart = value.split('@')[0];\r\n  validationsLen(localPart,{\r\n    min : getValidValue(minLenLocal,minLenLocal),\r\n    max : getValidValue(maxLenLocal,maxLenLocal),\r\n    minMessage : minLenLocal.errorMessage,\r\n    maxMessage : maxLenLocal.errorMessage\r\n  })\r\n  // Domain and subdomain length validation\r\n  const ArrayDomain = value.split('@')[1].split('.');\r\n  const domain = value.split('@')[1].trim();\r\n  const domainPart = ArrayDomain[ArrayDomain.length - 1];\r\n  const subdomain = domain.split(domainPart)[0].trim();\r\n  const hasSpecialChar = inputValidator(domainPart).hasSpecialCharacter()\r\n  ifTruthyValue(hasSpecialChar,'Subdomain should not contain special characters')\r\n  validationsLen(subdomain, {\r\n    min: getValidValue(minLenSubdomain,minLenSubdomain),\r\n    max:  getValidValue(maxLenSubdomain,maxLenSubdomain),\r\n    minMessage: minLenSubdomain.errorMessage,\r\n    maxMessage: maxLenSubdomain.errorMessage,\r\n  });\r\n  validationsLen(domainPart, {\r\n    min: getValidValue(minLenDomain, minLenDomain),\r\n    max: getValidValue(maxLenDomain, maxLenDomain),\r\n    minMessage: minLenDomain.errorMessage,\r\n    maxMessage: maxLenDomain.errorMessage,\r\n  });\r\n  // Email format validation using inputValidator\r\n  const validator = inputValidator(value);\r\n  const email = localPart+'@'+subdomain+domainPart\r\n  const isValidEmail = email ===value\r\n  const isValidFormat = validator.matchesEmailFormat(value);\r\n  IfNotType('boolean', isValidFormat, `Unexpected validation result. The email validation should return a boolean.`);\r\n  ifFalsyValue(isValidFormat, `The provided email address '${value}' is not valid. Please enter a valid email.`);\r\n  const isValid = isValidFormat && hasSymbol && isValidEmail\r\n  // If the input is a string and has a valid email format, return true\r\n  return isValid;\r\n}\r\nmodule.exports = validateEmail;\r\n","exports.toString = (value) => String(value);\r\n","const { MIN_LENGTH, MAX_LENGTH } = require(\"../../../common/validationConstants\");\r\nconst createValidationOptions = require(\"../../../utils/handleOption\");\r\nconst inputValidator = require(\"../../../utils/inputValidator\");\r\n\r\nfunction createOPtions (value,options){\r\n    const validator = inputValidator(value);\r\n    const optionName = ['minLength', 'maxLength', 'uppercase', 'lowercase', 'number', 'specialCharacter', 'alphabetic', 'whitespace'];\r\n    const optionValidations = [validator.hasMinLength(MIN_LENGTH), validator.hasMaxLength(MAX_LENGTH), true, true, true, true, true, false];\r\n    const msgError = [\r\n      'Password must be at least 8 characters long.',\r\n      'Password cannot exceed 20 characters.',\r\n      'Password must contain at least one uppercase letter.',\r\n      'Password must contain at least one lowercase letter.',\r\n      'Password must have at least one number.',\r\n      'Password must contain at least one special character such as (@#$%^&*).',\r\n      'Input must contain at least one alphabetic character.',\r\n      'Password cannot contain whitespace.'\r\n    ];\r\n    let objectOPtion =  createValidationOptions(optionName,optionValidations,msgError)\r\n    // Merge the values from 'options' into 'objectOPtion'\r\n    objectOPtion = { ...objectOPtion, ...options };\r\n    const { lowercase, uppercase, number, specialCharacter, alphabetic, whitespace, minLength, maxLength } = objectOPtion;\r\n    return { lowercase, uppercase, number, specialCharacter, alphabetic, whitespace, minLength, maxLength, msgError};\r\n\r\n}\r\nmodule.exports = createOPtions","const inputValidator = require(\"../../../utils/inputValidator\")\r\n\r\nexports.getReq = (value)=>{\r\n    return value.required\r\n}\r\n\r\nexports.getValue = (value)=>{\r\n    return value.value\r\n}\r\nexports.getErrorMessage = (value)=>{\r\n    return value.errorMessage\r\n}","\"use strict\";\r\n\r\n/**\r\n * Validates a password based on specified criteria.\r\n *\r\n * @typedef {Object} PasswordOptions\r\n * @property {Object} options - Options for customizing validation criteria.\r\n * @property {Object} options.minLength - Minimum length requirements for the password.\r\n * @property {number|string} options.minLength.value - The minimum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} options.minLength.errorMessage - Error message for minimum length validation failure.\r\n * @property {Object} options.maxLength - Maximum length requirements for the password.\r\n * @property {number|string} options.maxLength.value - The maximum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} options.maxLength.errorMessage - Error message for maximum length validation failure.\r\n * @property {Object} options.uppercase - Uppercase letter requirements for the password.\r\n * @property {boolean} options.uppercase.required - Whether uppercase letters are required.\r\n * @property {string} options.uppercase.errorMessage - Error message for uppercase letter validation failure.\r\n * @property {Object} options.lowercase - Lowercase letter requirements for the password.\r\n * @property {boolean} options.lowercase.required - Whether lowercase letters are required.\r\n * @property {string} options.lowercase.errorMessage - Error message for lowercase letter validation failure.\r\n * @property {Object} options.number - Numeric digit requirements for the password.\r\n * @property {boolean} options.number.required - Whether numeric digits are required.\r\n * @property {string} options.number.errorMessage - Error message for numeric digit validation failure.\r\n * @property {Object} options.specialCharacter - Special character requirements for the password.\r\n * @property {boolean} options.specialCharacter.required - Whether special characters are required.\r\n * @property {string} options.specialCharacter.errorMessage - Error message for special character validation failure.\r\n * @property {Object} options.alphabetic - Alphabetic character requirements for the password.\r\n * @property {boolean} options.alphabetic.required - Whether alphabetic characters are required.\r\n * @property {string} options.alphabetic.errorMessage - Error message for alphabetic character validation failure.\r\n * @property {Object} options.whitespace - Whitespace requirements for the password.\r\n * @property {boolean} options.whitespace.required - Whether whitespace is not allowed.\r\n * @property {string} options.whitespace.errorMessage - Error message for whitespace validation failure.\r\n */\r\n\r\n/**\r\n * Options for customizing password validation criteria.\r\n *\r\n * @typedef {Object} options\r\n * @property {Object} minLength - Minimum length requirements for the password.\r\n * @property {number|string} minLength.value - The minimum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} minLength.errorMessage - Error message for minimum length validation failure.\r\n * @property {Object} maxLength - Maximum length requirements for the password.\r\n * @property {number|string} maxLength.value - The maximum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} maxLength.errorMessage - Error message for maximum length validation failure.\r\n * @property {Object} uppercase - Uppercase letter requirements for the password.\r\n * @property {boolean} uppercase.required - Whether uppercase letters are required.\r\n * @property {string} uppercase.errorMessage - Error message for uppercase letter validation failure.\r\n * @property {Object} lowercase - Lowercase letter requirements for the password.\r\n * @property {boolean} lowercase.required - Whether lowercase letters are required.\r\n * @property {string} lowercase.errorMessage - Error message for lowercase letter validation failure.\r\n * @property {Object} number - Numeric digit requirements for the password.\r\n * @property {boolean} number.required - Whether numeric digits are required.\r\n * @property {string} number.errorMessage - Error message for numeric digit validation failure.\r\n * @property {Object} specialCharacter - Special character requirements for the password.\r\n * @property {boolean} specialCharacter.required - Whether special characters are required.\r\n * @property {string} specialCharacter.errorMessage - Error message for special character validation failure.\r\n * @property {Object} alphabetic - Alphabetic character requirements for the password.\r\n * @property {boolean} alphabetic.required - Whether alphabetic characters are required.\r\n * @property {string} alphabetic.errorMessage - Error message for alphabetic character validation failure.\r\n * @property {Object} whitespace - Whitespace requirements for the password.\r\n * @property {boolean} whitespace.required - Whether whitespace is not allowed.\r\n * @property {string} whitespace.errorMessage - Error message for whitespace validation failure.\r\n */\r\n\r\nconst { MAX_LENGTH, MIN_LENGTH, getValidValue, isValue, getFalseRequired } = require(\"../../common/validationConstants\");\r\nconst inputValidator = require(\"../../utils/inputValidator\");\r\nconst {isTypeMismatch}= require('../../errors/HandleError');\r\nconst { toString } = require(\"./helper/dataConversion\");\r\nconst createOptions = require(\"./helper/genOption\");\r\nconst { getReq, getErrorMessage } = require(\"./helper/getValues\");\r\nconst {  validateWithCondition, TypeMatches, validationsLength, IfBothTruthy } = require(\"../../errors/FormError\");\r\n\r\n/**\r\n * Validates a password based on the provided options.\r\n *\r\n * @param {string} input - The password string to be validated.\r\n * @param {options} options - Options for customizing validation criteria.\r\n * @returns {boolean} - True if the password is valid, otherwise false.\r\n * @throws {Error} - Throws an error if validation fails.\r\n * @example\r\n * const { isPassword } = require(\"vfyjs\");\r\n * const isValid = isPassword(\"StrongPwd@123\", { minLength: 8, uppercase: true, number: true });\r\n * console.log(isValid); // true\r\n */\r\nfunction validateFormPassword(input, options = {}) {\r\n    const value = input.value ? input.value : input\r\n    toString(value);\r\n    const validator = inputValidator(input);\r\n    const { lowercase, uppercase, number, specialCharacter, alphabetic, whitespace, minLength, maxLength, msgError } = createOptions(value, options);\r\n    validateWithCondition(getReq(uppercase), validator.hasUppercase(), input, msgError, 'hasUppercase', getErrorMessage(uppercase));\r\n    validateWithCondition(getReq(lowercase), validator.hasLowerCase(), input, msgError, 'hasLowerCase', getErrorMessage(lowercase));\r\n    validateWithCondition(getReq(number), validator.hasNumber(), input, msgError, 'hasNumber', getErrorMessage(number));\r\n    validateWithCondition(getReq(specialCharacter), validator.hasSpecialCharacter(), input, msgError, 'hasSpecialCharacter', getErrorMessage(specialCharacter));\r\n    validateWithCondition(getReq(alphabetic), validator.hasAlphabetic(), input, msgError, 'hasAlphabetic', getErrorMessage(alphabetic));\r\n    let whitespaceCheck = getFalseRequired(whitespace);\r\n    IfBothTruthy(!whitespaceCheck, validator.hasWhitespace(), \"Whitespace is not allowed. Please remove any leading or trailing spaces.\",input,msgError,'hasWhitespace');\r\n\r\n    const minValidLength = getValidValue(minLength, MIN_LENGTH);\r\n    const maxValidLength = getValidValue(maxLength, MAX_LENGTH);\r\n    let min = isValue(minLength, minValidLength);\r\n    let max = isValue(maxLength, maxValidLength);\r\n\r\n    if (typeof min === 'string' || typeof min === 'string') {\r\n        min = +min;\r\n        max = +max;\r\n    }\r\n\r\n    if (isTypeMismatch('undefined', min) &&\r\n        isTypeMismatch('undefined', max) &&\r\n        isTypeMismatch('boolean', min) &&\r\n        isTypeMismatch('boolean', max) &&\r\n        isTypeMismatch('number', min) &&\r\n        isTypeMismatch('number', max)) {\r\n        throw new TypeError(\"Invalid configuration for minLength or maxLength. They must be either true, false, or a numeric value or string.\");\r\n    }\r\n\r\n    TypeMatches('number', min, getErrorMessage(minLength));\r\n    TypeMatches('number', max, getErrorMessage(maxLength));\r\n    validationsLength(value, min, max, `Password length must be between ${min} and ${max} characters.`, input, msgError, 'validations Length');\r\n\r\n    const isValid = min &&\r\n        max &&\r\n        (uppercase.required ? validator.hasUppercase() : true) &&\r\n        (lowercase.required ? validator.hasLowerCase() : true) &&\r\n        (number.required ? validator.hasNumber() : true) &&\r\n        (specialCharacter.required ? validator.hasSpecialCharacter() : true) &&\r\n        (alphabetic.required ? validator.hasAlphabetic() : true) &&\r\n        !whitespaceCheck;\r\n\r\n    return isValid;\r\n  }\r\nmodule.exports = validateFormPassword;","\"use strict\";\r\n\r\n/**\r\n * Options for customizing password validation criteria.\r\n *\r\n * @typedef {Object} options\r\n * @property {Object} minLength - Minimum length requirements for the password.\r\n * @property {(number|string)} minLength.value - The minimum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} minLength.errorMessage - Error message for minimum length validation failure.\r\n * @property {Object} maxLength - Maximum length requirements for the password.\r\n * @property {(number|string)} maxLength.value - The maximum length value. If not provided, it defaults to the value from the validation constants.\r\n * @property {string} maxLength.errorMessage - Error message for maximum length validation failure.\r\n * @property {Object} uppercase - Uppercase letter requirements for the password.\r\n * @property {boolean} uppercase.required - Whether uppercase letters are required.\r\n * @property {string} uppercase.errorMessage - Error message for uppercase letter validation failure.\r\n * @property {Object} number - Lowercase letter requirements for the password.\r\n * @property {boolean} number.required - Whether lowercase letters are required.\r\n * @property {string} number.errorMessage - Error message for lowercase letter validation failure.\r\n * @property {Object} NonAlphanumeric - Numeric digit requirements for the password.\r\n * @property {boolean} NonAlphanumeric.required - Whether numeric digits are required.\r\n * @property {string} NonAlphanumeric.errorMessage - Error message for numeric digit validation failure.\r\n * @property {Object} trim - Special character requirements for the password.\r\n * @property {boolean} trim.required - Whether special characters are required.\r\n * @property {string} trim.errorMessage - Error message for special character validation failure.\r\n * @property {Object} repeat - Alphabetic character requirements for the password.\r\n * @property {boolean} repeat.required - Whether alphabetic characters are required.\r\n * @property {string} repeat.errorMessage - Error message for alphabetic character validation failure.\r\n */\r\n\r\nconst {MAX_LENGTH,MIN_LENGTH,getFalseRequired,trimmedValue,getValidValue,isValue,getRequired } = require(\"../../common/validationConstants\");\r\nconst inputValidator = require(\"../../utils/inputValidator\");\r\nconst createValidationOptions = require('../../utils/handleOption')\r\nconst { ifFalsyValue,validateIfBothTruthy , ifTruthyValue,isTypeMismatch ,validatePropertyLengthAndType} = require(\"../../errors/HandleError\");\r\n/**\r\n * Validates a password based on the provided options.\r\n *\r\n * @param {string} value - The password string to be validated.\r\n * @param {options} options - Options for customizing validation criteria.\r\n * @returns {boolean} - True if the password is valid, otherwise false.\r\n * @throws {Error} - Throws an error if validation fails.\r\n * @example\r\n * const { username } = require(\"vfyjs\");\r\n * const isValid = username(\"StringUsername123\");\r\n * console.log(isValid); // true\r\n */\r\nfunction validateUsername(username, options = {}) {\r\n    const validator = inputValidator(username);\r\n    const optionName = ['minLength', 'maxLength', 'uppercase','number','NonAlphanumeric','trim','repeat']\r\n    const validation = \r\n    [\r\n        validator.hasMinLength(MIN_LENGTH),\r\n        validator.hasMaxLength(MAX_LENGTH),\r\n        validator.hasUppercase(),\r\n        validator.hasNumber(),\r\n        validator.hasNonAlphanumeric(),\r\n        validator.hasWhitespace(),\r\n        validator.hasRepeat()\r\n    ]\r\n    const messageError = \r\n    [\r\n        'Username must be at least 8 characters long.',\r\n        'Username cannot exceed 64 characters.',\r\n        'Username must contain at least one uppercase letter.',\r\n        'Username must have at least one number.',\r\n        'Username must not contain non-alphanumeric characters.',\r\n        'Username cannot contain whitespace.',\r\n        'Username must not have consecutive repeated characters.'\r\n    ]\r\n    let objectOption = createValidationOptions(optionName,validation,messageError)\r\n    objectOption = {...objectOption, ...options}\r\n    const {minLength,\r\n        maxLength,\r\n        uppercase,\r\n        number,\r\n        NonAlphanumeric,\r\n        trim,\r\n        repeat } = objectOption\r\n    ifFalsyValue(uppercase.required ? validator.hasUppercase() : true  , uppercase.errorMessage)\r\n    ifFalsyValue(number.required , number.errorMessage)\r\n    let checkWhiteSpace = getRequired(trim, false)\r\n    if(checkWhiteSpace){\r\n        ifFalsyValue(!checkWhiteSpace ? validator.hasWhitespace() : true, 'Invalid input. Value cannot contain leading or trailing whitespaces.');\r\n    }  \r\n    username = trimmedValue(username)\r\n    const isNonAlphanumeric = getRequired(NonAlphanumeric,false)\r\n    ifTruthyValue(isNonAlphanumeric, 'Value must be alphanumeric. Example: ABC123');\r\n\r\n    const isNumber = getRequired(number,validator.hasNumber())\r\n    validateIfBothTruthy(isNumber , !validator.hasNumber() && !validator.hasNumeric(),'Invalid input. The password must contain at least one number.')\r\n    let isRepeat = getFalseRequired(repeat , validator.hasRepeat())\r\n    validateIfBothTruthy(isRepeat,validator.hasRepeat() , 'Invalid input. Password cannot have consecutive repeated characters.')\r\n    let minValue = getValidValue(minLength , minLength);\r\n    let maxValue = getValidValue(maxLength , maxLength);\r\n        \r\n    const min = isValue(minValue,MIN_LENGTH)\r\n    const max = isValue(maxValue,MAX_LENGTH)\r\n    if (typeof minValue === 'string' || typeof maxValue === 'string') {\r\n        minValue = +minValue;\r\n        maxValue =+maxValue\r\n    }\r\n    \r\n    validatePropertyLengthAndType(min,max,'number','number', username,`Invalid configuration for minimum and maximum length. Ensure that ${min} and ${max} are either set to true, false, or numeric values or strings.`)\r\n    if(typeof max === 'number' && username.length > max){\r\n        throw new Error('Username length exceeds the maximum allowed length.');\r\n    }\r\n    \r\n    isTypeMismatch('undefined', minValue,\"undefined 1\") \r\n    isTypeMismatch('undefined', maxValue,\"undefined 2\")\r\n    isTypeMismatch('boolean', minValue,\"boolean 1\") \r\n    isTypeMismatch('boolean', maxValue,\"boolean 2\")\r\n    isTypeMismatch('number', min,\"number 1\") \r\n    isTypeMismatch('number', max,\"number 2\")\r\n    const isValid = min && max && (uppercase.required ? validator.hasUppercase() : true) && isNumber && !isNonAlphanumeric && !checkWhiteSpace && !isRepeat\r\n    return isValid;\r\n}\r\nmodule.exports = validateUsername;\r\n","const { trimmedValue } = require(\"../../common/validationConstants\");\r\nconst { IfNotType, IfIsNumber, ifTruthyValue, ifFalsyValue } = require(\"../../errors/HandleError\");\r\nconst inputValidation = require('../../utils/inputValidator');\r\n\r\n/**\r\n * Validates if the given URL is an HTTP URL.\r\n *\r\n * @param {string} url - The URL to be validated.\r\n * @returns {boolean} Returns true if the URL is a valid HTTP URL, otherwise false.\r\n * @throws {TypeError} Throws a TypeError if the input is not a string.\r\n * @throws {Error} Throws an Error if the input is a number or if the protocol is not 'http:'.\r\n *\r\n * @example\r\n * // Example 1: Valid HTTP URL\r\n * const result1 = isHttp(\"http://www.example.com\");\r\n * console.log(result1); // Output: true\r\n *\r\n * @example\r\n * // Example 2: Handling an invalid HTTPS URL with try-catch\r\n * try {\r\n *   const result2 = isHttp(\"https://www.example.com\");\r\n *   console.log(result2);\r\n * } catch (error) {\r\n *   console.error(error.message); // Output: \"Only HTTP URLs are allowed.\"\r\n * }\r\n */\r\nfunction isHttp(url) {\r\n    // Check if the URL contains the substring \"http\"\r\n    const isHttp = /(?=.*(HTTP|http))/.test(url);\r\n    ifFalsyValue(isHttp, 'The URL must contain the substring \"http\". Please provide a valid URL.');\r\n\r\n    // Check if the URL is empty\r\n    if (url === \"\") {\r\n        throw new Error(\"URL cannot be empty. Please provide a valid URL.\");\r\n    }\r\n\r\n    // Perform type and numeric checks\r\n    IfNotType('string', url, 'URL must be a string.');\r\n    IfIsNumber(url, 'URL must not be a number.');\r\n\r\n    // Trim the URL\r\n    url = trimmedValue(url);\r\n\r\n    /**\r\n     * The URL object representing the validated URL.\r\n     * @type {URL}\r\n     */\r\n    let { protocol, hostname, href } = new URL(url);\r\n\r\n    // Convert protocol to lowercase and trim\r\n    protocol = protocol.toLowerCase();\r\n    protocol = trimmedValue(protocol);\r\n\r\n    /**\r\n     * Validates if the URL uses the 'https' protocol and throws an error if it does.\r\n     */\r\n    ifTruthyValue(protocol.startsWith('https'), \"Only HTTP URLs are allowed.\");\r\n\r\n    // Check HTTP format\r\n    const hasHttp = /(HTTP:|http:)\\/\\/[^\\/]/i.test(url);\r\n\r\n    // Validate special characters in the hostname\r\n    const host = hostname.split('.')[1];\r\n    const validator = inputValidation(host);\r\n    const hasSpecial = validator.hasSpecialCharacter();\r\n    ifTruthyValue(hasSpecial, `The hostname \"${hostname}\" in the URL \"${href}\" must contain at least one special character.`);\r\n\r\n    // Check if the protocol is 'http' and the URL is in the correct format\r\n    return protocol && hasHttp;\r\n}\r\nmodule.exports = isHttp;\r\n","const { trimmedValue } = require(\"../../common/validationConstants\");\r\nconst { IfNotType, IfIsNumber, ifTruthyValue, ifFalsyValue } = require(\"../../errors/HandleError\");\r\nconst inputValidation = require('../../utils/inputValidator');\r\n\r\n/**\r\n * Validates if the given URL is an HTTPS URL.\r\n *\r\n * @param {string} url - The URL to be validated.\r\n * @returns {boolean} Returns true if the URL is a valid HTTPS URL, otherwise false.\r\n * @throws {TypeError} Throws a TypeError if the input is not a string.\r\n * @throws {Error} Throws an Error if the input is a number or if the protocol is not 'https:'.\r\n *\r\n * @example\r\n * // Example 1: Valid HTTPS URL\r\n * const result1 = isHttps(\"https://www.example.com\");\r\n * console.log(result1); // Output: true\r\n *\r\n * @example\r\n * // Example 2: Handling an invalid HTTP URL with try-catch\r\n * try {\r\n *   const result2 = isHttps(\"http://www.example.com\");\r\n *   console.log(result2);\r\n * } catch (error) {\r\n *   console.error(error.message); // Output: \"Only HTTPS URLs are allowed.\"\r\n * }\r\n */\r\nfunction isHttpsUrl(url) {\r\n    // Check if the URL contains the substring \"https\"\r\n    const isHttps = /(?=.*(HTTPS|https))/.test(url);\r\n    ifFalsyValue(isHttps, 'The URL must contain the substring \"https\". Please provide a valid URL.');\r\n\r\n    // Check if the URL is empty\r\n    if (url === \"\") {\r\n        throw new Error(\"URL cannot be empty. Please provide a valid URL.\");\r\n    }\r\n\r\n    // Perform type and numeric checks\r\n    IfNotType('string', url, 'URL must be a string.');\r\n    IfIsNumber(url, 'URL must not be a number.');\r\n\r\n    // Trim the URL\r\n    url = trimmedValue(url);\r\n\r\n    /**\r\n     * The URL object representing the validated URL.\r\n     * @type {URL}\r\n     */\r\n    let { protocol, hostname, href } = new URL(url);\r\n\r\n    // Convert protocol to lowercase and trim\r\n    protocol = protocol.toLowerCase();\r\n    protocol = trimmedValue(protocol);\r\n\r\n    // Check HTTPS format\r\n    const hasHttps = /(HTTPS:|https:)\\/\\/[^\\/]/i.test(url);\r\n\r\n    // Validate special characters in the hostname\r\n    const host = hostname.split('.')[1];\r\n    const validator = inputValidation(host);\r\n    const hasSpecial = validator.hasSpecialCharacter();\r\n    ifTruthyValue(hasSpecial, `The hostname \"${hostname}\" in the URL \"${href}\" must contain at least one special character.`);\r\n\r\n    // Check if the protocol is 'https' and the URL is in the correct format\r\n    return protocol && hasHttps;\r\n}\r\nmodule.exports = isHttpsUrl;","\"use strict\";\r\nconst fs = require(\"fs\").promises;\r\nconst path = require(\"path\");\r\n/**\r\n * Reads and extracts phone code information from the specified JSON file.\r\n *\r\n * @returns {Promise<{countries: string[], phoneCodes: string[], isoCodes: string[]}>} - A Promise that resolves to an object containing arrays of countries, phone codes, and ISO codes.\r\n * @throws {Error} - Throws an error if there is an issue reading the file or parsing the JSON.\r\n */\r\nasync function readPhoneCodeData() {\r\n  /**\r\n   * @type {string} - The path to the JSON file containing phone code information.\r\n   */\r\n  const filePath = path.join(__dirname, '..','resources','countryCodes.json');\r\n\r\n  try {\r\n    // Read the JSON file\r\n    const jsonData = await fs.readFile(filePath, \"utf8\");\r\n    const phoneCodeData = JSON.parse(jsonData);\r\n\r\n    /**\r\n     * Array containing names of countries.\r\n     * @type {string[]}\r\n     */\r\n    let countries = [];\r\n\r\n    /**\r\n     * Array containing phone codes.\r\n     * @type {string[]}\r\n     */\r\n    let phoneCodes = [];\r\n\r\n    /**\r\n     * Array containing ISO codes.\r\n     * @type {string[]}\r\n     */\r\n    let isoCodes = [];\r\n\r\n    // Extract information from the JSON data\r\n    phoneCodeData.forEach((countryData) => {\r\n      countries.push(countryData.country);\r\n      phoneCodes.push(countryData.code);\r\n      isoCodes.push(countryData.iso);\r\n    });\r\n\r\n    // Return an object with arrays of information\r\n    return {\r\n      countries,\r\n      phoneCodes,\r\n      isoCodes,\r\n    };\r\n  } catch (error) {\r\n    /**\r\n     * Throws an error if there is an issue reading the file or parsing the JSON.\r\n     * @throws {Error}\r\n     */\r\n    throw new Error(`Error reading or parsing JSON: ${error.message}`);\r\n  }\r\n}\r\n/**\r\n * Reads and extracts phone pattern information from the specified JSON file.\r\n *\r\n * @async\r\n * @function\r\n * @returns {Promise<{\r\n*   countries: string[],\r\n*   phoneCodes: string[],\r\n*   continent: string[],\r\n*   format: object[]\r\n* }>} - A Promise that resolves to an object containing arrays of countries, phone codes, continents, and phone number formats.\r\n* @throws {Error} - Throws an error if there is an issue reading the file or parsing the JSON.\r\n*/\r\nasync function getTelResource() {\r\n /**\r\n  * @type {string} - The path to the JSON file containing phone pattern information.\r\n  */\r\n  const filePath = path.join(__dirname, '..','resources','TelResource.json');\r\n\r\n try {\r\n   // Read the JSON file\r\n   const jsonData = await fs.readFile(filePath, \"utf8\");\r\n   const phoneFormats = JSON.parse(jsonData);\r\n\r\n   /**\r\n    * Array containing names of countries.\r\n    * @type {string[]}\r\n    */\r\n   let countries = [];\r\n\r\n   /**\r\n    * Array containing phone codes.\r\n    * @type {string[]}\r\n    */\r\n   let phoneCodes = [];\r\n\r\n   /**\r\n    * Array containing continents.\r\n    * @type {string[]}\r\n    */\r\n   let continentArray = [];\r\n\r\n   /**\r\n    * Array containing phone number formats.\r\n    * @type {object[]}\r\n    */\r\n   let format = [];\r\n\r\n   // Extract information from the JSON data\r\n   phoneFormats.forEach((formats) => {\r\n     countries.push(formats.country);\r\n     continentArray.push(formats.continent);\r\n     phoneCodes.push(formats.countryCode);\r\n     format.push(formats.formats);\r\n   });\r\n\r\n   // Create a Set to get unique continents\r\n\r\n   // Convert Set to array using spread operator\r\n   const continent = [...continentArray]\r\n\r\n   return {\r\n     countries,\r\n     phoneCodes,\r\n     continent,\r\n     format,\r\n   };\r\n } catch (error) {\r\n   /**\r\n    * Throws an error if there is an issue reading the file or parsing the JSON.\r\n    * @throws {Error}\r\n    */\r\n   throw new Error(`Error reading or parsing JSON: ${error.message}`);\r\n }\r\n}\r\nmodule.exports = {getTelResource , readPhoneCodeData};\r\n","const { Djibouti, Morocco, Kenya,SouthAfrica }= require('../countries/Africa')\r\nfunction AfricaPhoneNumber(value){\r\n    const country = value.country\r\n    switch (country){\r\n        case \"Djibouti\":\r\n            return Djibouti(value)\r\n        case \"Morocco\":\r\n            return Morocco(value)\r\n        case \"Kenya\":\r\n            return Kenya(value)\r\n        case \"South Africa\":\r\n            return SouthAfrica(value)\r\n    }\r\n}\r\n\r\nmodule.exports = AfricaPhoneNumber","const { CostaRica, Guatemala, ElSalvador ,Honduras}=require('../../countries/America/central')\r\nfunction CentralPhoneNumber(value){\r\n    const country = value.country\r\n    switch(country){\r\n        case \"Costa Rica\":\r\n            return CostaRica(value)\r\n        case \"El Salvador\":\r\n            return ElSalvador(value)\r\n        case \"Guatemala\":\r\n            return Guatemala(value)\r\n        case \"Honduras\":\r\n            return Honduras(value)\r\n    }\r\n}\r\nmodule.exports = CentralPhoneNumber","const {CanadaOrUs, Mexico} = require('../../countries/America/north')\r\nfunction NorthPhoneNumber(value){\r\n    const country = value.country\r\n    if (Array.isArray(country)) {\r\n        switch(country[0] || country[1]){\r\n            case \"Canada\":\r\n            case \"United States\":\r\n                return CanadaOrUs(value)\r\n        }\r\n    }\r\n    return Mexico(value)\r\n}\r\nmodule.exports = NorthPhoneNumber","const { Argentina, Brazil, Peru } = require(\"../../countries/America/south\")\r\n\r\nfunction SouthPhoneNumber(value){\r\n    const country = value.country\r\n    switch(country){\r\n        case \"Argentina\":\r\n            return Argentina(value)\r\n        case \"Brazil\":\r\n            return Brazil(value)\r\n        case \"Peru\":\r\n            return Peru(value)\r\n    }\r\n}\r\nmodule.exports = SouthPhoneNumber","const {iran,China,HongKongAndMacau, India, Japan, Malaysia, Pakistan, Philippines, Singapore, SriLanka, SouthKorea, Taiwan, Thailand} = require('../countries/Asian')\r\nfunction AsiaPhoneNumber(value){\r\n    const country = value.country\r\n    switch (country){\r\n        case \"China\":\r\n            return China(value)\r\n        case \"Hong Kong and Macau\":\r\n        case \"Hong Kong\":\r\n            return HongKongAndMacau(value)\r\n        case \"India\":\r\n            return India(value)\r\n        case \"Iran\":\r\n            return iran(value)\r\n        case \"Japan\":\r\n            return Japan(value)\r\n        case \"Malaysia\":\r\n            return Malaysia(value)\r\n        case \"Pakistan\":\r\n            return Pakistan(value)\r\n        case \"Philippines\":\r\n            return Philippines(value)\r\n        case \"Singapore\":\r\n            return Singapore(value)\r\n        case \"Sri Lanka\":\r\n            return SriLanka(value)\r\n        case \"South Korea\":\r\n            return SouthKorea(value)\r\n        case \"Taiwan\":\r\n            return Taiwan(value)\r\n        case \"Thailand\":\r\n            return Thailand(value)\r\n    }\r\n}\r\n\r\nmodule.exports = AsiaPhoneNumber","const {KazakhstanOrRussia,Romania,Portugal,Poland, Belgium, Denmark, Finland,France ,Germany,Greece,Hungary,Iceland,Ireland,Italy,Netherlands,Norway} = require(\"../countries/Europe\")\r\n\r\nfunction EuropePhoneNumber(value){\r\n    const country = value.country\r\n    if (Array.isArray(country)) {\r\n        switch(country[0] || country[1]){\r\n            case \"Kazakhstan\":\r\n            case \"Russia\":\r\n                return KazakhstanOrRussia(value)\r\n        }\r\n    }\r\n    switch (country){\r\n        case \"Belgium\":\r\n            return Belgium(value)\r\n        case \"Denmark\":\r\n            return Denmark(value)\r\n        case \"Finland\":\r\n            return Finland(value)\r\n        case \"France\":\r\n            return France(value)\r\n        case \"Germany\":\r\n            return Germany(value)\r\n        case \"Greece\":\r\n            return Greece(value)\r\n        case \"Hungary\":\r\n            return Hungary(value)\r\n        case \"Iceland\":\r\n            return Iceland(value)\r\n        case \"Ireland\":\r\n            return Ireland(value)\r\n        case \"Italy\":\r\n            return Italy(value)\r\n        case \"Netherlands\":\r\n            return Netherlands(value)\r\n        case \"Norway\":\r\n            return Norway(value)\r\n        case \"Poland\":\r\n            return Poland(value)\r\n        case \"Portugal\":\r\n            return Portugal(value)\r\n        case \"Romania\":\r\n            return Romania(value)\r\n    }\r\n}\r\n\r\nmodule.exports = EuropePhoneNumber","const {Australia, NewZealand} = require('../countries/Oceania')\r\nfunction OceaniaPhoneNumber(value){\r\n    const country = value.country\r\n    switch (country){\r\n        case \"Australia\":\r\n            return Australia(value)\r\n        case \"New Zealand\":\r\n            return NewZealand(value)\r\n    }\r\n}\r\n\r\nmodule.exports = OceaniaPhoneNumber","const {generateValidationResult, validatedCountry} = require('../utils/FormatValidation')\r\nconst countries  = [ 'Djibouti' ,'Morocco', 'Kenya' ,'SouthAfrica']\r\ncountries.forEach((country)=>{\r\n    exports[country] = (values)=>{\r\n        return validatedCountry(values,generateValidationResult)\r\n    }\r\n})","const { extractInfoValue, getSubstring, validationFormats, generateValidationResult } = require(\"../../utils/FormatValidation\")\r\nconst Validations = (values, countryCode) => {\r\n    const {code, hasCode, hasPhone, patterns, phone } = extractInfoValue(values);\r\n\r\n    let formats;\r\n    switch (countryCode) {\r\n        case 'CostaRica':\r\n            formats = [\r\n                getSubstring(phone, [0, 3], [3, 6], [6]),\r\n                getSubstring(phone, [0, 3], [3, 6], [6]),\r\n                getSubstring(phone, [0, 4], [4]),\r\n                getSubstring(phone, [0, 4], [4])\r\n            ];\r\n            break;\r\n        case 'ElSalvador':\r\n            formats = [\r\n                getSubstring(phone, [0, 3], [3, 6], [6]),\r\n                getSubstring(phone, [0, 4], [4]),\r\n                getSubstring(phone, [0, 4], [4])\r\n            ];\r\n            break;\r\n        case \"Guatemala\":\r\n            formats =[\r\n                `+${code}${phone}`,\r\n                getSubstring(phone,[0,4],[4]),\r\n                getSubstring(phone,[0,4],[4]),\r\n            ]\r\n            break;\r\n        case 'Honduras':\r\n            formats = [\r\n                getSubstring(phone,[0,4],[4]),\r\n                getSubstring(phone,[0,4],[4]),\r\n            ]\r\n    }\r\n\r\n    const hasValidFormat = validationFormats(patterns, formats);\r\n    return generateValidationResult(values, hasValidFormat, hasCode, hasPhone);\r\n};\r\nexports.CostaRica = (values)=>{\r\n    return Validations(values,'CostaRica')\r\n}\r\nexports.ElSalvador = (values)=>{\r\n    return Validations(values,'ElSalvador')\r\n}\r\nexports.Guatemala = (values)=>{\r\n    return Validations(values,'Guatemala')\r\n}\r\nexports.Honduras = (values)=>{\r\n    return Validations(values,'Honduras')\r\n}","const { extractInfoValue, getSubstring, validationFormats, generateValidationResult } = require(\"../../utils/FormatValidation\")\r\nexports.CanadaOrUs = (values)=>{\r\n    const { code ,hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    const formattedTollFree = getSubstring(phone,[0,1],[1,4],[4,7],[7])\r\n    const formattedService = `+${code}${phone}`\r\n    const formattedMobile = getSubstring(phone,[0,3],[3,6],[6])\r\n    const format = [formattedTollFree,formattedService,formattedMobile,formattedMobile]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,true)\r\n}\r\nexports.Mexico = (values)=>{\r\n    const {hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    const formattedTollFree = getSubstring(phone,[0,1],[1,4],[4,7],[7])\r\n    const formattedService =getSubstring(phone,[0,1],[1,4],[4,6],[6])\r\n    const format = [formattedTollFree,formattedService,phone,phone]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone)\r\n}","const { generateValidationResult, validationCountry } = require(\"../../utils/FormatValidation\");\r\nconst countries = ['Argentina','Brazil','Peru']\r\ncountries.forEach(country =>{\r\n    exports[country] = (values)=>{\r\n       return validationCountry(values,generateValidationResult,4)\r\n    }\r\n})","const {generateValidationResult , validationFormats,extractInfoValue,getSubstring, customSubstring, validatedCountry, validationCountry} = require('../utils/FormatValidation')\r\nexports.iran = (values) => {\r\n    const { code, phone, patterns,hasCode,hasPhone } = extractInfoValue(values)\r\n    const format = [ `0${phone}`,`+${code}0${phone}`, `0${phone}`]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false);\r\n  };\r\n\r\nexports.China = (values)=>{\r\n    const { hasCode,patterns,hasPhone,phone} = extractInfoValue(values)\r\n    const format = [phone, phone, `0${phone}`, phone];\r\n    const hasValidFormat =validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.HongKongAndMacau = (values)=>{\r\n    return validationCountry(values,generateValidationResult,1)\r\n}\r\nexports.India = (values)=>{\r\n    const { code,hasCode,hasPhone,patterns,phone } = extractInfoValue(values)\r\n    const LandlinePhone = phone.split(phone.length - 4)\r\n    const sectionOne = LandlinePhone[0]\r\n    const sectionTwo = LandlinePhone[1]\r\n    const landline = `${sectionOne}-${sectionTwo}`;\r\n    let tollFree = phone\r\n    const hasStartWithOne =  tollFree.startsWith(\"1\")\r\n    const numbers = tollFree.split('800')[1]\r\n    const hasSixNumber = /^\\d{6}$/.test(numbers)\r\n    let format;\r\n    if (hasStartWithOne && hasSixNumber) {\r\n        format = [`+${code}${phone}`,phone,landline,tollFree]\r\n    }else{\r\n        format = [`+${code}${phone}`,phone,landline,false]\r\n    }\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.Japan = (values)=>{\r\n    const {hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    const [w,r,y]=getSubstring(phone,[0,4],[4,6],[6])\r\n    const formattedPhoneNumber = `${w}-${r}-${y}`;\r\n    const [h,j,l] = getSubstring(phone,[0,2],[2,6],[6])\r\n    const hasStartZero = phone.startsWith(\"0\")\r\n    let format;\r\n    if (hasStartZero) {\r\n        const formattedLandLineNumber = `${h}-${j}-${l}`\r\n        format = [formattedPhoneNumber,phone,formattedLandLineNumber]\r\n    }else{\r\n        format = [formattedPhoneNumber,phone,false]\r\n    }\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.Malaysia = (values)=>{\r\n    const {code,hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    // Mobile Number Formatting\r\n    const [m,s] = getSubstring(phone,[0,3],[3])\r\n    const formattedMobile = `${m}-${s}`;\r\n    // Service Number Formatting\r\n    const [c,f,g,n] = getSubstring(phone,[0,1],[1,4],[4,6],[6])\r\n    const formattedService = `${c}-${f}-${g}-${n}`;\r\n    // Landline Number Formatting\r\n    const [ h,t]= getSubstring(phone,[0,2],[2])\r\n    const formattedLandline = `${h}-${t}`;\r\n    // Toll-Free Number Formatting\r\n    const [w,r,u,i] = getSubstring(phone,[0,1],[1,4],[4,6],[6])\r\n    const formattedTollFreeNumber = `${w}-${r}-${u}-${i}`;\r\n    const format = [formattedMobile,formattedService,formattedLandline,formattedTollFreeNumber]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.Pakistan = (values)=>{\r\n    return validationCountry(values,generateValidationResult)\r\n}\r\nexports.Philippines = (values)=>{\r\n    const { hasCode,hasPhone,patterns,phone } = extractInfoValue(values)\r\n    const format = [phone,phone]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)    \r\n}\r\nexports.Singapore = (values)=>{\r\n    return  validatedCountry(values,generateValidationResult)\r\n}\r\nexports.SriLanka = (values)=>{\r\n    const {hasCode,hasPhone,patterns,phone,} = extractInfoValue(values)\r\n    const [w,f,g] = getSubstring(phone,[0,3],[3,6],[6])\r\n    const formattedLandline = `${w}-${f}-${g}`\r\n    const [h,j,u ] = getSubstring(phone,[0,3],[3,7],[7])\r\n    const formattedTollFreeNumber = `${h}-${j}-${u}`\r\n    const format = [phone,phone,formattedLandline,formattedTollFreeNumber]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.SouthKorea = (values)=>{\r\n    const {hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    const [w,f,g] = getSubstring(phone,[0,3],[3,7],[7])\r\n    const formattedMobile = `${w}-${f}-${g}`\r\n    const [c,y,j] = getSubstring(phone,[0,2],[2,6],[6])\r\n    const formattedLandline = `${c}-${y}-${j}`\r\n    const format = [formattedMobile,formattedLandline,phone]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.Taiwan = (values)=>{\r\n    const {code,hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n    let formattedMobile = `+${code}${phone}`\r\n    const [f,k] = getSubstring(phone,[0,2],[2])\r\n    const formattedLandline = `${f}-${k}`\r\n    const format = [formattedMobile,formattedLandline]\r\n    const hasValidFormat = validationFormats(patterns,format)\r\n    return generateValidationResult(values,hasValidFormat,hasCode,hasPhone,false)\r\n}\r\nexports.Thailand = (values)=>{\r\n    return validationCountry(values,generateValidationResult,2)\r\n}","const { validationCountry, generateValidationResult, validatedCountry, extractInfoValue, validationFormats } = require(\"../utils/FormatValidation\")\r\nconst countries = ['KazakhstanOrRussia','Romania','Portugal','Poland','Belgium','Denmark','Finland','France','Germany','Greece','Hungary','Iceland','Ireland','Italy','Netherlands','Norway']\r\ncountries.forEach((country)=>{\r\n    exports[country] = (values)=>{\r\n        const { code,phone} = extractInfoValue(values)\r\n        const international = `+${code}${phone}`\r\n        let format;\r\n        if (values.patterns.length <=2) {\r\n            format = [international,phone]\r\n        }else{\r\n            format = [international,phone,phone]\r\n        }\r\n        return validatedCountry(values,generateValidationResult,format)\r\n    }\r\n})","const { validationCountry, generateValidationResult } = require(\"../utils/FormatValidation\")\r\nconst countries = ['Australia', 'NewZealand'];\r\ncountries.forEach(country => {\r\n    exports[country] = (values) => {\r\n        const lastDigit = country === 'Australia' ? 4 : 1;\r\n        return validationCountry(values, generateValidationResult, lastDigit);\r\n    }\r\n});","const { GlobalVal } = require('./utils/GlobalValidation');\r\nconst AsiaPhoneNumber = require('./continents/Asia');\r\nconst AfricaPhoneNumber = require('./continents/Africa');\r\nconst OceaniaPhoneNumber = require('./continents/Oceania');\r\nconst EuropePhoneNumber = require('./continents/Europe');\r\nconst NorthAmericaPhoneNumber = require('./continents/America/north');\r\nconst CentralAmericaPhoneNumber = require('./continents/America/central');\r\nconst SouthAmericaPhoneNumber = require('./continents/America/south');\r\n\r\n/**\r\n * Validates a phone number based on its country code and phone number.\r\n *\r\n * @param {string} code - The country code of the phone number.\r\n * @param {string} phone - The phone number to be validated.\r\n * @returns {Promise<object>} - A promise that resolves to an object containing information about the validated phone number.\r\n *\r\n * @example\r\n * // Example: Validating a US phone number\r\n * const usCode = '1';\r\n * const usPhoneNumber = '1234567890';\r\n * validatePhoneNumber(usCode, usPhoneNumber)\r\n *   .then(result => {\r\n *     // The result object contains detailed information about the validated phone number\r\n *     console.log('Validation Result:');\r\n *     console.log('-------------------');\r\n *     console.log('Continent:', result.continent);\r\n *     console.log('Country:', result.country);\r\n *     console.log('Country Code:', result.code);\r\n *     console.log('ISO Codes:', result.isoCode);\r\n *     console.log('Phone Number:', result.phone);\r\n *     console.log('Has Country Code:', result.hasCode);\r\n *     console.log('Has Phone Number:', result.hasPhone);\r\n *     console.log('Is Duplicate Code:', result.isDuplicateCode);\r\n *     console.log('Is Toll-Free:', result.tollFree);\r\n *     console.log('Is Service Number:', result.service);\r\n *     console.log('Is Landline Number:', result.landline);\r\n *     console.log('Is Mobile Number:', result.mobile);\r\n *   })\r\n *   .catch(error => {\r\n *     console.error(error);\r\n *   });\r\n */\r\nasync function validatePhoneNumber(code, phone) {\r\n  // Get information about the phone number using GlobalVal function\r\n  const informationPhone = await GlobalVal(code, phone);\r\n\r\n  // Switch based on the continent and call the respective validation function\r\n  switch (informationPhone.continent) {\r\n    case \"Asia\":\r\n      return AsiaPhoneNumber(informationPhone);\r\n\r\n    case \"Africa\":\r\n      return AfricaPhoneNumber(informationPhone);\r\n\r\n    case \"Oceania\":\r\n      return OceaniaPhoneNumber(informationPhone);\r\n\r\n    case \"Europe\":\r\n      return EuropePhoneNumber(informationPhone);\r\n\r\n    case \"North America\":\r\n      return NorthAmericaPhoneNumber(informationPhone);\r\n\r\n    case \"Central America\":\r\n      return CentralAmericaPhoneNumber(informationPhone);\r\n\r\n    case \"South America\":\r\n      return SouthAmericaPhoneNumber(informationPhone);\r\n  }\r\n}\r\nmodule.exports = validatePhoneNumber;\r\n","/**\r\n * Validates the provided formats against a set of patterns.\r\n *\r\n * @param {Array<Object>} patterns - An array of objects containing patterns to match.\r\n * @param {string} mobile - The mobile format to be validated.\r\n * @param {string} landline - The landline format to be validated.\r\n * @param {string} service - The service format to be validated.\r\n * @returns {Array<boolean>} - An array of boolean values indicating the validity of each format against the corresponding pattern.\r\n * \r\n * @typedef {Array<boolean>} ValidationResultArray - An array indicating the validity of each format against the corresponding pattern.\r\n * Each boolean value in the array represents the validity of the corresponding format (mobile, service, landline).\r\n */\r\nfunction validationFormats(patterns,formats) {\r\n  /**\r\n   * Map through the patterns and test each format against its corresponding pattern.\r\n  *\r\n  * @param {Object} patternObj - The pattern object containing the regex pattern.\r\n  * @param {number} index - The index of the pattern in the array.\r\n  * @returns {boolean} - True if the format matches the pattern, false otherwise.\r\n  */\r\n return patterns.map((patternObj, index) => {\r\n   // Create a regex object from the pattern\r\n   const regex = new RegExp(patternObj.pattern);\r\n   // Test the format against the pattern\r\n   const testResult = regex.test(formats.length?formats[index] : formats);\r\n    return testResult;\r\n  });\r\n}\r\n\r\n/**\r\n * Generates a validation result object based on the validity of different formats.\r\n *\r\n * @param {Object} values - The input values object.\r\n * @param {Array<boolean>} hasValidFormat - An array of boolean values indicating the validity of each format.\r\n * @param {boolean} hasCode - Indicates if the code is valid.\r\n * @param {boolean} hasPhone - Indicates if the phone number is valid.\r\n * @param {boolean} [isDuplicateCode=false] - Indicates if there is a duplicate code.\r\n * @returns {ValidationResult} - The generated validation result object.\r\n */\r\nfunction generateValidationResult(values, hasValidFormat, hasCode, hasPhone, isDuplicateCode=false) {\r\n  const defaultValue = null\r\n  const result = {\r\n    continent: values.continent,\r\n    country: values.country,\r\n    code: values.code,\r\n    isoCode: values.iso,\r\n    phone: values.phone,\r\n    hasCode: hasCode,\r\n    hasPhone: hasPhone,\r\n    isDuplicateCode: isDuplicateCode,\r\n  };\r\n  values.patterns.forEach((format, index) => {\r\n    /**\r\n     * Dynamic property name based on format type.\r\n     * @type {boolean}\r\n     */\r\n    let propertyName = format.type;\r\n    if (propertyName === 'toll-free') {\r\n      propertyName = 'tollFree'\r\n    }\r\n    result[propertyName] = hasValidFormat[index] !== undefined ? hasValidFormat[index] : defaultValue;\r\n  });\r\n  return result;\r\n}\r\n/**\r\n * Extracts information values from the provided object.\r\n *\r\n * @param {Object} values - The input object containing information values.\r\n * @param {string} values.code - The code value to be extracted.\r\n * @param {string} values.phone - The phone value to be extracted.\r\n * @param {string[]} values.patterns - The patterns value to be extracted (an array of strings).\r\n * @param {boolean} values.hasCode - Indicates whether the object has the 'code' property.\r\n * @param {boolean} values.hasPhone - Indicates whether the object has the 'phone' property.\r\n * @returns {ExtractInfoValue} An object containing the extracted information values.\r\n /**\r\n * @typedef {Object} ExtractInfoValue\r\n * @property {string} code - The extracted code value.\r\n * @property {string} phone - The extracted phone value.\r\n * @property {string[]} patterns - The extracted patterns value.\r\n * @property {boolean} hasCode - Indicates whether the object has the 'code' property.\r\n * @property {boolean} hasPhone - Indicates whether the object has the 'phone' property.\r\n * @example\r\n * const inputObject = {\r\n *   code: \"ABC123\",\r\n *   phone: \"555-1234\",\r\n *   patterns: [\"pattern1\", \"pattern2\"],\r\n *   hasCode: true,\r\n *   hasPhone: false,\r\n * };\r\n * const extractedValues = extractInfoValue(inputObject);\r\n * console.log(extractedValues);\r\n * // Output: { code: 'ABC123', phone: '555-1234', patterns: ['pattern1', 'pattern2'], hasCode: true, hasPhone: false }\r\n */\r\nfunction extractInfoValue(values) {\r\n  // Destructure the input object\r\n  const { code, phone, patterns, hasCode, hasPhone } = values;\r\n\r\n  // Return an object with the extracted values\r\n  return { code, phone, patterns, hasCode, hasPhone };\r\n}\r\n/**\r\n * Extracts substrings from the given input string based on the specified ranges.\r\n *\r\n * @param {string} input - The input string from which substrings will be extracted.\r\n * @param {...number[]} ranges - Variable number of ranges specified as pairs of start and end indices.\r\n * @returns {string} - A formatted string created by joining the extracted substrings with hyphens.\r\n *\r\n * @example\r\n * const inputString = \"Hello, World!\";\r\n * const result = getSubstring(inputString, [0, 5], [7, 12]);\r\n * console.log(result);\r\n * // Output: 'Hello-World'\r\n */\r\nfunction getSubstring(input, ...ranges) {\r\n  const formattedString = ranges.map(([start, end]) => input.substring(start, end)).join('-');\r\n  return formattedString;\r\n}\r\n/**\r\n * Validates country information using the provided function and returns the result.\r\n *\r\n * @param {Object} values - The input values object.\r\n * @param {function} func - The function to validate the country information.\r\n * @returns {ValidationResult} - The generated validation result object.\r\n *\r\n * @typedef {Object} ValidationResult\r\n * @property {string} continent - Validated continent.\r\n * @property {string} code - Validated phone code.\r\n * @property {string} country - Validated country.\r\n * @property {string} isoCode - Validated ISO code.\r\n * @property {string} phone - Validated phone number.\r\n * @property {Array} patterns - An array of formatting patterns for the phone code.\r\n * Each pattern is an object with 'type' and 'pattern' properties.\r\n * @property {boolean} isValidMobileFormat - Indicates if the mobile format is valid (true) or not (false).\r\n * @property {boolean} isValidServiceFormat - Indicates if the service format is valid (true) or not (false).\r\n * @property {boolean} isValidLandlineFormat - Indicates if the landline format is valid (true) or not (false).\r\n * @property {boolean} hasCode - Indicates if the code is valid (true) or not (false).\r\n * @property {boolean} hasPhone - Indicates if the phone number is valid (true) or not (false).\r\n * @property {boolean} isDuplicateCode - Indicates if there is a duplicate code (true) or not (false).\r\n */\r\nfunction validatedCountry(values,func,formats){\r\n  const {code,hasCode,hasPhone,patterns,phone} = extractInfoValue(values)\r\n  const international = `+${code}${phone}`\r\n  const format = formats || [phone,international,phone]\r\n  const hasValidFormat = validationFormats(patterns,format)\r\n  return func(values,hasValidFormat,hasCode,hasPhone)\r\n}\r\n/**\r\n * Validates phone formats for a specific country using a custom validation function.\r\n *\r\n * @param {Object} values - The input values object.\r\n * @param {Function} func - The validation function to be applied.\r\n * @param {...string} phones - Phone numbers to be validated.\r\n * @returns {ValidationResult} - The generated validation result object.\r\n */\r\nfunction validationCountry(values, func, numberFormat=1) {\r\n  const { code, hasCode, hasPhone, patterns, phone } = extractInfoValue(values);\r\n  const phoneFormats = Array.from({ length: numberFormat }, () => phone);\r\n  const hasValidFormat = validationFormats(patterns, ...phoneFormats);\r\n  return func(values, hasValidFormat, hasCode, hasPhone);\r\n}\r\n\r\n/**\r\n * @typedef {Object} ValidationResult\r\n * @property {string} continent - Validated continent.\r\n * @property {string} code - Validated phone code.\r\n * @property {string} country - Validated country.\r\n * @property {string} isoCode - Validated ISO code.\r\n * @property {string} phone - Validated phone number.\r\n * @property {Array} patterns - An array of formatting patterns for the phone code.\r\n * Each pattern is an object with 'type' and 'pattern' properties.\r\n * @property {boolean} isValidMobileFormat - Indicates if the mobile format is valid (true) or not (false).\r\n * @property {boolean} isValidServiceFormat - Indicates if the service format is valid (true) or not (false).\r\n * @property {boolean} isValidLandlineFormat - Indicates if the landline format is valid (true) or not (false).\r\n * @property {boolean} hasCode - Indicates if the code is valid (true) or not (false).\r\n * @property {boolean} hasPhone - Indicates if the phone number is valid (true) or not (false).\r\n * @property {boolean} isDuplicateCode - Indicates if there is a duplicate code (true) or not (false).\r\n */\r\nmodule.exports = { validationFormats, generateValidationResult,extractInfoValue ,getSubstring,validatedCountry ,validationCountry};\r\n","\"use strict\";\r\nconst {getTelResource,readPhoneCodeData} = require(\"../config/phoneDataHandler\")\r\nconst { trimmedValue } = require('../../../common/validationConstants')\r\nconst { TypesCheck, isEmpty, validateLength, ifFalsyValue, ifTruthyValue }= require('../../../errors/HandleError')\r\nconst inputValidator = require('../../../utils/inputValidator')\r\nconst MAX_LENGTH_CODE = 10\r\nconst MIN_LENGTH_CODE = 1\r\nconst MAX_LENGTH_PHONE_NUMBER = 25\r\nconst MIN_LENGTH_PHONE_NUMBER = 6\r\n\r\n\r\n/**\r\n * Validates a given value based on specified criteria.\r\n *\r\n * @param {string|number} value - The value to be validated.\r\n * @param {number} min - The minimum length allowed.\r\n * @param {number} max - The maximum length allowed.\r\n * @param {string} [ContentError=String] - The type of content being validated (default is 'String').\r\n * @returns {string} - The trimmed and validated value.\r\n */\r\nfunction ChecKValue(value, min, max, ContentError = String) {\r\n    if (typeof (value) === 'number') {\r\n        value = `${value}`;\r\n    }\r\n    const hasSpecialChar = inputValidator(value).hasSpecialCharacter()\r\n    ifTruthyValue(hasSpecialChar,'Special characters are not allowed.')\r\n    //  trim validated value\r\n    value = trimmedValue(value)\r\n    // Check for empty value\r\n    isEmpty(value, `${ContentError} should not be empty. Please provide a valid ${ContentError}.`);\r\n    // Check for valid types\r\n    TypesCheck(value, ['string', 'number'], `Invalid ${ContentError}. ${ContentError} should be a string or a number.`);\r\n    // Convert value to a string\r\n    const stringValue = String(value);\r\n\r\n    // Check if it starts with '0'\r\n    const startsWithZero = stringValue.startsWith('0');\r\n    \r\n    let numberCode = +value;\r\n    \r\n    const validator = inputValidator(numberCode);\r\n    // Check for numeric characters\r\n    ifFalsyValue(validator.hasNumeric(), `Invalid ${ContentError} format. The ${ContentError} should contain numeric characters.`);\r\n    // Convert to string if the value is a number\r\n    if (typeof (numberCode) === 'number') {\r\n        numberCode = `${numberCode}`;\r\n\r\n    }\r\n    if (startsWithZero) {\r\n        numberCode = \"0\"+numberCode\r\n    }\r\n    if (typeof (value) === 'number') {\r\n        value = `${value}`;\r\n    }\r\n    if (numberCode.length !== value.length) {\r\n        throw new Error(`${ContentError} length mismatch after conversion to a number.`);\r\n    }  \r\n    // Validate length\r\n    validateLength(numberCode, min, max, `Invalid ${ContentError} length. The ${ContentError} should be between ${min} and ${max} characters.`);\r\n    //  return the validated value\r\n    return numberCode;\r\n}\r\n/**\r\n * @typedef {Object} PhoneCodeValidationResult\r\n * @property {string} code - Validated phone code.\r\n * @property {string} country - Validated country.\r\n * @property {string} iso - Validated ISO code.\r\n * @property {boolean} hasCode - Indicates if the code is valid (true) or not (false).\r\n * @example\r\n * const validatedCode = await hasCode('98');\r\n * if (validatedCode) {\r\n *    console.log(validatedCode.code); // Validated phone code\r\n *    console.log(validatedCode.country); // Validated country\r\n *    console.log(validatedCode.iso); // Validated ISO code\r\n *    console.log(validatedCode.hasCode); // true\r\n * } else {\r\n *    console.log('Invalid phone code');\r\n * }\r\n */\r\n/**\r\n * Represents the result of validating a phone code.\r\n *\r\n * @param {string|number} code - The phone code to be validated.\r\n * @returns {Promise<PhoneCodeValidationResult|boolean>} - An object with validated information or false if invalid.\r\n */\r\nasync function hasCode(code) {\r\n    // Validate the code using ChecKValue function\r\n    const validatedValue = ChecKValue(code, MIN_LENGTH_CODE, MAX_LENGTH_CODE, 'Code');\r\n    \r\n    const isFind = await findEqualCodes(validatedValue)\r\n    // console.log('isFind =>',isFind);\r\n    // Fetch phone code data\r\n    const phoneCodeData = await readPhoneCodeData();\r\n    // Check for error fetching data\r\n    ifFalsyValue(phoneCodeData, 'Error fetching phone code data. Please try again later.');\r\n\r\n    // Retrieve phone codes, iso codes, and countries\r\n    const phoneCodes = phoneCodeData.phoneCodes;\r\n    const isoCodes = phoneCodeData.isoCodes;\r\n    const countries = phoneCodeData.countries;\r\n\r\n    // Find the index of the validated code\r\n    const index = phoneCodes.indexOf(validatedValue);\r\n    if (isFind.length > 0) {\r\n        return isFind;  // Return the array when there are matching codes\r\n    } else {\r\n        return index !== -1 ? {\r\n            code: phoneCodes[index],\r\n            country: countries[index],\r\n            iso: isoCodes[index],\r\n            hasCode: true,\r\n            code: validatedValue,\r\n        } : false;\r\n    }\r\n}\r\n/**\r\n * Finds phone codes that match specified criteria and retrieves associated information.\r\n *\r\n * @async\r\n * @function\r\n * @param {string|number} code - The code to search for matches.\r\n * @returns {Promise<Array<Object>>} - An array of objects containing ISO codes, phone codes, and countries.\r\n * @throws {Error} - Throws an error if there is an issue fetching phone code data.\r\n *\r\n * @example\r\n * const equalCodes = [\"1\"];\r\n * const matchingCodes = await findEqualCodes(equalCodes);\r\n * console.log(matchingCodes);\r\n */\r\nasync function findEqualCodes(code){\r\n    let equalCodes=[\"1\",\"7\"]\r\n    // Fetch phone code data\r\n    const phoneCodeData = await readPhoneCodeData();\r\n    // Check for error fetching data\r\n    ifFalsyValue(phoneCodeData, 'Error fetching phone code data. Please try again later.');\r\n\r\n    // Retrieve phone codes, iso codes, and countries\r\n    const phoneCodes = phoneCodeData.phoneCodes;\r\n    const isoCodes = phoneCodeData.isoCodes;\r\n    const countries = phoneCodeData.countries;\r\n     // Use reduce to accumulate matching codes\r\n     const matchingData = phoneCodes.reduce((accumulator, value, index) => {\r\n        if (equalCodes.includes(value) && +value === +code) {\r\n            const isoCode = isoCodes[index];\r\n            const country = countries[index];\r\n            accumulator.push({ isoCode, code: value, country});\r\n        }\r\n        return accumulator;\r\n    }, []);\r\n    return matchingData\r\n    \r\n}\r\n/**\r\n * @typedef {Object} PhoneNumberValidationResult\r\n * @property {string} phone - Validated phone number.\r\n * @property {boolean} hasPhone - Indicates if the phone number is valid (true) or not (false).\r\n * @example\r\n * const validatedPhoneNumber = hasPhone('9115291407');\r\n * if (validatedPhoneNumber) {\r\n *    console.log(validatedPhoneNumber.phone); // Validated phone number\r\n *    console.log(validatedPhoneNumber.hasPhone); // true\r\n * } else {\r\n *    console.log('Invalid phone number');\r\n * }\r\n */\r\n/**\r\n * Represents the result of validating a phone number.\r\n *\r\n * @param {string|number} phone - The phone number to be validated.\r\n * @returns {PhoneNumberValidationResult|boolean} - An object with validated information or false if invalid.\r\n */\r\nfunction hasPhone(phone) {\r\n    // Validate the phone number using ChecKValue function\r\n    const validatedPhoneNumber = ChecKValue(phone, MIN_LENGTH_PHONE_NUMBER, MAX_LENGTH_PHONE_NUMBER, \"Phone Number\");\r\n\r\n    // Return information if valid, otherwise false\r\n    return validatedPhoneNumber ? {\r\n        phone: validatedPhoneNumber,\r\n        hasPhone: true\r\n    } : false;\r\n}\r\n/**\r\n * @typedef {Object} ContinentInfoResult\r\n * @property {string} continent - The continent associated with the phone code.\r\n * @property {Array} patterns - An array of formatting patterns for the phone code.\r\n *   Each pattern is an object with 'type' and 'pattern' properties.\r\n * @example\r\n * const continentInfo = await getContinentInfo('98');\r\n * if (continentInfo) {\r\n *    console.log(continentInfo.continent); // Continent information\r\n *    console.log(continentInfo.patterns); // Formatting patterns\r\n * } else {\r\n *    console.log('Invalid phone code');\r\n * }\r\n */\r\n\r\n/**\r\n * Represents the result of retrieving continent and formatting patterns information for a phone code.\r\n *\r\n * @async\r\n * @param {string|number} code - The phone code for which continent information is retrieved.\r\n * @returns {Promise<ContinentInfoResult|boolean>} - An object with continent and patterns information or false if invalid.\r\n */\r\nasync function getContinentInfo(code) {\r\n    try {\r\n        const phoneData = await getTelResource();\r\n        const index = phoneData.phoneCodes.indexOf(code);\r\n        // Return information if valid, otherwise false\r\n        return index !== -1 ? {\r\n            continent: phoneData.continent[index],\r\n            patterns: phoneData.format[index],\r\n        } : false;\r\n    } catch (error) {\r\n        // Log unexpected errors and throw a generic error message\r\n        throw new Error('Internal server error. Please try again later.');\r\n    }\r\n}\r\n/**\r\n * @typedef {Object} ValidationResult\r\n * @property {string} continent - Validated continent.\r\n * @property {string} code - Validated phone code.\r\n * @property {string} country - Validated country.\r\n * @property {string} iso - Validated ISO code.\r\n * @property {string} phone - Validated phone number.\r\n * @property {Array} patterns - An array of formatting patterns for the phone code.\r\n *   Each pattern is an object with 'type' and 'pattern' properties.\r\n * @property {boolean} hasCode - Indicates if the code is valid (true) or not (false).\r\n * @property {boolean} hasPhone - Indicates if the phone number is valid (true) or not (false).\r\n */\r\n/**\r\n * Validates both country code and phone number and returns information if both are valid.\r\n *\r\n * @param {string|number} code - The country code to be validated.\r\n * @param {string|number} phone - The phone number to be validated.\r\n * @returns {Promise<ValidationResult>}  - An object with validated information.\r\n * @throws Will throw an error if validation fails.\r\n */\r\n\r\nasync function GlobalVal(code, phone) {\r\n        // Validate country code and phone number\r\n        const validatedCode = await hasCode(code);\r\n        const validatedPhone = await hasPhone(phone);\r\n        // Check for validation failures\r\n        ifFalsyValue(validatedCode, 'Failed to validate country code.');\r\n        ifFalsyValue(validatedPhone, 'Failed to validate phone number.');\r\n        if (Array.isArray(validatedCode)) {\r\n            const uniqueValues = validatedCode.reduce((acc, obj) => {\r\n                acc.code = obj.code;\r\n                if (!acc.isoCode) {\r\n                    acc.isoCode = [];\r\n                }\r\n                if (!acc.country) {\r\n                    acc.country = [];\r\n                }\r\n                if (!acc.isoCode.includes(obj.isoCode)) {\r\n                    acc.isoCode.push(obj.isoCode);\r\n                }\r\n                if (!acc.country.includes(obj.country)) {\r\n                    acc.country.push(obj.country);\r\n                }\r\n                return acc;\r\n            }, {});\r\n            const ContinentInfo =await getContinentInfo(uniqueValues.code)\r\n            return{\r\n                continent : ContinentInfo.continent,\r\n                code : uniqueValues.code,\r\n                country : uniqueValues.country,\r\n                iso : uniqueValues.isoCode,\r\n                phone : validatedPhone.phone,\r\n                patterns: ContinentInfo.patterns,\r\n                hasCode: true,\r\n                duplicateCodes : true,\r\n                hasPhone: validatedPhone.hasPhone,\r\n            }\r\n            // return uniqueValues\r\n        }else{\r\n            const ContinentInfo =await getContinentInfo(validatedCode.code)\r\n            // Return validated information\r\n            return {\r\n                continent : ContinentInfo.continent,\r\n                code: validatedCode.code,\r\n                country: validatedCode.country,\r\n                iso: validatedCode.iso,\r\n                phone: validatedPhone.phone,\r\n                patterns: ContinentInfo.patterns,\r\n                hasCode: validatedCode.hasCode,\r\n                hasPhone: validatedPhone.hasPhone,\r\n                duplicateCodes : false,\r\n            };\r\n        }\r\n}\r\nmodule.exports = {\r\n    hasCode,\r\n    hasPhone,\r\n    getContinentInfo,\r\n    GlobalVal,\r\n    ChecKValue,\r\n    findEqualCodes\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(10);\n"],"names":["root","factory","exports","module","define","amd","this","passwordValidate","emailValidate","userValidate","isHttp","isHttps","colorValidate","validatePhoneNumber","inputValidations","getSubstring","trimmedValue","HandleError","MathOperations","isPassword","isEmail","isUsername","isColor","hasPhone","trimValue","mathOperations","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","name","_format","parse","ret","delimiter","win32","MIN_LENGTH","MAX_LENGTH","getFalseRequired","value","required","replace","trim","getValidValue","defaultValue","isValue","getRequired","toString","ValidationError","Error","constructor","message","property","input","errors","validationRule","fieldType","statusError","super","timestamp","Date","getErrorDetails","getFormattedMessage","id","logError","getInput","ValueTypeError","StringLengthError","BooleanValueError","throwIfFalsy","ifTruthyValue","validateWithCondition","condition","validatorFunction","msgError","errorMessage","TypeMatches","expectedType","validationsLength","minLength","maxLength","IfBothTruthy","method","CustomError","LengthError","ifFalsyValue","validateIfBothTruthy","IfNotType","isTypeMismatch","IfTypeMatches","IfIsNumber","isNaN","validateLength","validatePropertyLengthAndType","minLengthType","maxLengthType","TypesCheck","types","includes","isEmpty","validationsLen","options","min","minMessage","max","maxMessage","validateMinLen","validateMaxLen","handleOption","option","validations","errorMessages","optionName","validation","hasUppercase","test","hasLowerCase","hasNumber","hasSpecialCharacter","hasAlphabetic","hasNumeric","hasAlphanumeric","hasWhitespace","hasNonAlphanumeric","hasMinLength","hasMaxLength","matchesCustomPattern","pattern","matchesEmailFormat","hasRepeat","repeatCount","RegExp","number","numbers","isEqual","every","num","isEven","areAllOdd","isOdd","areAllEven","add","reduce","acc","curr","subtract","isDivisibleBy","divisibleBy","forEach","multiply","divide","power","generateRandomNumber","Math","floor","random","generateRandomEvenNumber","randomNumber","generateRandomOddNumber","color","HEX","NameColor","RGB","RGBA","HSL","CssVar","HWB","inputValidator","createValidationOptions","hasSymbol","hasOneDot","objectOPtion","minLenLocal","minLenDomain","minLenSubdomain","maxLenLocal","maxLenDomain","maxLenSubdomain","localPart","split","ArrayDomain","domain","domainPart","subdomain","hasSpecialChar","isValidEmail","isValidFormat","String","validator","optionValidations","lowercase","uppercase","specialCharacter","alphabetic","whitespace","getReq","getValue","getErrorMessage","createOptions","whitespaceCheck","minValidLength","maxValidLength","username","objectOption","NonAlphanumeric","repeat","checkWhiteSpace","isNonAlphanumeric","isNumber","isRepeat","minValue","maxValue","inputValidation","url","protocol","hostname","href","URL","toLowerCase","startsWith","hasHttp","host","hasSpecial","hasHttps","fs","getTelResource","async","filePath","jsonData","readFile","phoneFormats","countries","phoneCodes","continentArray","formats","push","country","continent","countryCode","error","readPhoneCodeData","phoneCodeData","isoCodes","countryData","iso","Djibouti","Morocco","Kenya","SouthAfrica","CostaRica","Guatemala","ElSalvador","Honduras","CanadaOrUs","Mexico","Array","isArray","Argentina","Brazil","Peru","iran","China","HongKongAndMacau","India","Japan","Malaysia","Pakistan","Philippines","Singapore","SriLanka","SouthKorea","Taiwan","Thailand","KazakhstanOrRussia","Romania","Portugal","Poland","Belgium","Denmark","Finland","France","Germany","Greece","Hungary","Iceland","Ireland","Italy","Netherlands","Norway","Australia","NewZealand","generateValidationResult","validatedCountry","values","extractInfoValue","validationFormats","Validations","hasCode","patterns","phone","hasValidFormat","formattedTollFree","formattedService","formattedMobile","validationCountry","customSubstring","LandlinePhone","landline","tollFree","hasStartWithOne","hasSixNumber","w","r","y","formattedPhoneNumber","h","j","l","m","s","c","f","g","n","t","formattedLandline","u","k","international","GlobalVal","AsiaPhoneNumber","AfricaPhoneNumber","OceaniaPhoneNumber","EuropePhoneNumber","NorthAmericaPhoneNumber","CentralAmericaPhoneNumber","SouthAmericaPhoneNumber","informationPhone","map","patternObj","index","isDuplicateCode","result","isoCode","propertyName","type","ranges","substring","func","numberFormat","ChecKValue","ContentError","startsWithZero","numberCode","validatedValue","isFind","findEqualCodes","indexOf","equalCodes","accumulator","validatedPhoneNumber","getContinentInfo","phoneData","validatedCode","validatedPhone","uniqueValues","obj","ContinentInfo","duplicateCodes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}